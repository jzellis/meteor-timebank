{"version":3,"file":"/packages/mongodb-aggregation.js","sources":["mongodb-aggregation/server.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;GAAK,CAAI,EAAT,GAAK;;AAEL,IAAG,EAAM,EAAT;CAEE,EAAO,CAAP,EAAO;CAAP,CACA,CAAU,IAAV,EAAU;CADV,CAEA,CAAS,CAAgB,EAAzB,CAAS,CAAY;CAFrB,CAIA,CAAwB,GAAM,IAAN,OAAxB;CAJA,CAOA,CAAiB,MAAC,CAAD,IAAjB;CACE;AAAU,CAAV,IAAgC,CAAtB,EAAJ,EAAG,OAAH;AACe,CADrB,EACoB,CAApB,CAA2C,CAAtB,EAAJ,EAAG,IAApB;CADA,CAK4B,CAApB,CAAR,EAAyB,IAAjB;AAEC,CAPT,EAOS,CAAT;CAPA,CAQA,CAAK,CAAL,EAAW,EAAN;CARL,CASyB,EAAzB,CAAM;CACU,EAAP,GAAT;CAlBF,EAOiB;CAPjB,CAsBA,IAAM,CAAN;CACE,CAAuB,EAAvB;EAIgB,EAAhB,EAAgB,GAAC,CAAD,IAAhB;CACE;AAAU,CAAV,IAAgC,CAAhC,EAAM,EAAG,OAAH;AACe,CADrB,EACoB,EAAuB,CAA3C,EAAiB,EAAG,IAApB;;CAEI,CAAF,CAAiD,CAAyE,CAA5H,CAAU,CAA8G,CAAxH,CAAwH,EAA9G,CAAmG,EAAnG;OAHV;EAI4B,CAApB,EAAR,KAAQ;AAEC,CANT,EAMS,GAAT;CANA,CAQqB,CAArB,EAAK,CAAL;CAEI;IAAqB,IAArB;MAAM,IAAN;;GACA;CAAM,CAAiB,IAAM,IAAtB;CAAD,CAA+C,GAAP;CAD9C;CAEO,CAAa,CAAN,GAAR,SAAN;CAJJ,MAAsC;CARtC,EAcS,GAAT;AAGoB,CAApB,GAAmB,EAAnB;MAAa,QAAP;OAjBN;CAmBA,GAAG,EAAH;CACE,GAAU,EAAM,EAAhB,EAAU;CAAV,CACyC,IAAnC,CAAN,EAAyC,KAAzC;CACM,EAAD,CAAH;CAAS,CAAS,GAAR;CAAQ,CAAM,CAAL;aAAV;CAD8B,WACvC;CADF,QAAyC;OArB3C;CAuBO,YAAP;CA5BF,IAIgB;CA3BlB,GAsBA;CAtBA,CAwDA,QAA0B;CAExB,CAAU,EAAV,KAAW;CAEM,CAAQ,CAAvB,CAAgB,CAAhB;CAFF,IAAU;CAAV,CAIW,EAAX,IAAW,CAAX;CACiB,CAAQ,EAAP,CAAhB;CALF,IAIW;CAJX,CAOW,EAAX,EAAW,GAAX;CACS,CAAwB,EAAE,CAAjC,CAAM,CAAyB,MAA/B;CARF,IAOW;CAjEb,GAwDA;CA5DF;A","sourcesContent":["tl = TLog?.getLogger()\n#hacky advanced mongo definitions based on https://github.com/meteor/meteor/pull/644\nif Meteor.isServer\n\n  path = Npm.require(\"path\")\n  MongoDB = Npm.require(\"mongodb\")\n  Future = Npm.require(path.join(\"fibers\", \"future\"))\n\n  _dummyCollection_ = new Meteor.Collection '__dummy__'\n\n  # Wrapper of the call to the db into a Future\n  _futureWrapper = (collection, commandName, args)->\n    col = if (typeof collection) == \"string\" then  _dummyCollection_ else collection\n    collectionName = if (typeof collection) == \"string\" then  collection else collection._name\n\n    #tl?.debug \"future Wrapper called for collection \" + collectionName + \" command: \" + commandName + \" args: \" + args\n    \n    coll1 = col.find()._mongo.db.collection(collectionName)\n\n    future = new Future\n    cb = future.resolver()\n    coll1[commandName](args, cb)\n    result = future.wait()\n    \n\n  # exposing the methods to the client\n  Meteor.methods\n    _callAdvancedDBMethod: _futureWrapper\n\n    # Not really DRY, but have to return slightly different results from mapReduce as mongo method returns\n    # a mongo collection, which we don't need here at all\n    _callMapReduce: (collection, map, reduce, options)->\n      col = if (typeof collection) == \"string\" then  _dummyCollection_ else collection\n      collectionName = if (typeof collection) == \"string\" then  collection else collection._name\n\n      tl?.debug \"callMapReduce called for collection \" + collectionName + \" map: \" + map + \" reduce: \" + reduce + \" options: #{JSON.stringify(options)}\"\n      coll1 = col.find()._mongo.db.collection(collectionName)\n\n      future = new Future\n      #cb = future.resolver()\n      coll1.mapReduce map, reduce, options, (err,result,stats)->\n          #tl?.debug \"Inside MapReduce callback now!\"\n          future.throw(err) if err\n          res = {collectionName: result.collectionName, stats: stats}\n          future.return [true,res]\n\n      result = future.wait() #\n      #console.log \"Result from the callMapReduce is: \"\n      #console.dir result[1]\n      throw result[1] if !result[0]\n\n      if result[1].collectionName\n        col = new Meteor.Collection result[1].collectionName\n        Meteor.publish result[1].collectionName, ->\n          col.find {\"_id\" : {$ne: \"\"}} # hack to allow Meteor fetching the values as apparently it does not support empty ids\n      result[1]\n\n\n\n  # Extending Collection on the server\n  _.extend Meteor.Collection::,\n\n    distinct: (key) ->\n      #_collectionDistinct @_name, key, query, options\n      _futureWrapper @_name, \"distinct\", key\n\n    aggregate: (pipeline) ->\n      _futureWrapper @_name, \"aggregate\", pipeline\n\n    mapReduce: (map, reduce, options)->\n      Meteor.apply \"_callMapReduce\", [@_name, map, reduce, options]\n\n\n\n"]}