{"version":3,"file":"/packages/ctl.js","sources":["ctl/ctl.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,0C;;AAEA,mB;AACA,e;AACA,yB;AACA,oC;AACA,kB;AACA,oC;AACA,qB;;AAEA,oC;AACA,G;AACA,G;;AAEA,gC;AACA,yC;AACA,yB;AACA,4B;AACA,c;AACA,gF;AACA,oB;AACA,M;AACA,oB;AACA,G;AACA,0C;AACA,kC;AACA,4C;AACA,gD;AACA,kC;AACA,6D;AACA,uE;AACA,G;AACA,0D;AACA,+D;AACA,E;;AAEA,mB;AACA,gB;AACA,yB;AACA,gB;AACA,G;;;AAGA,mB;AACA,oB;AACA,0C;AACA,gB;AACA,G;;AAEA,gC;AACA,yC;AACA,yB;AACA,2B;AACA,c;AACA,4E;AACA,8B;AACA,M;AACA,oB;AACA,G;;AAEA,2E;AACA,oB;AACA,8B;AACA,+D;AACA,+B;AACA,4B;AACA,kC;AACA,a;AACA,sB;AACA,iB;AACA,a;AACA,mC;AACA,K;AACA,iC;AACA,E;;AAEA,mB;AACA,e;AACA,wB;AACA,e;AACA,G;;AAEA,mD;AACA,yB;AACA,oB;AACA,O;AACA,yD;AACA,6B;AACA,qB;AACA,qB;AACA,0B;AACA,Q;AACA,+B;AACA,qB;AACA,0B;AACA,Q;AACA,+B;AACA,wB;AACA,O;AACA,O;AACA,iE;AACA,e;AACA,sB;AACA,e;AACA,a;AACA,uB;AACA,G;AACA,E;;;AAGA,mB;AACA,sB;AACA,2C;AACA,yB;AACA,4C;AACA,oC;AACA,8C;AACA,4D;AACA,0B;AACA,2B;AACA,gC;AACA,wB;AACA,iB;AACA,M;AACA,uD;AACA,wC;AACA,8C;AACA,2B;AACA,yB;AACA,wB;AACA,iB;AACA,e;AACA,sD;AACA,mD;AACA,+E;AACA,6C;AACA,0C;AACA,gD;AACA,0D;AACA,O;AACA,0D;AACA,wC;AACA,uC;AACA,M;AACA,gF;AACA,+B;AACA,e;AACA,gC;AACA,W;AACA,iB;AACA,Y;AACA,W;AACA,iB;AACA,Y;AACA,W;AACA,iB;AACA,Y;AACA,Y;AACA,gC;AACA,iD;AACA,Y;AACA,K;AACA,8E;AACA,a;AACA,gF;;AAEA,uE;AACA,uD;AACA,iD;AACA,uB;AACA,wC;AACA,+B;AACA,uC;AACA,6E;AACA,+B;AACA,+C;AACA,K;AACA,iE;AACA,e;AACA,2B;AACA,gC;AACA,+B;AACA,iB;AACA,+B;AACA,qC;AACA,O;AACA,U;AACA,oB;AACA,G;AACA,G;;AAEA,wB;AACA,wB;AACA,E","sourcesContent":["var Future = Npm.require(\"fibers/future\");\n\nCtl.Commands.push({\n  name: \"help\",\n  func: function (argv) {\n    if (!argv._.length || argv.help)\n      Ctl.usage();\n    var cmd = argv._.splice(0,1)[0];\n    argv.help = true;\n\n    Ctl.findCommand(cmd).func(argv);\n  }\n});\n\nvar startFun = function (argv) {\n  if (argv.help || argv._.length !== 0) {\n    process.stderr.write(\n      \"Usage: ctl start\\n\" +\n        \"\\n\" +\n        \"Starts the app. For now, this just means that it runs the 'server'\\n\" +\n        \"program.\\n\"\n    );\n    process.exit(1);\n  }\n  Ctl.subscribeToAppJobs(Ctl.myAppName());\n  var jobs = Ctl.jobsCollection();\n  var thisJob = jobs.findOne(Ctl.myJobId());\n  Ctl.updateProxyActiveTags(['', thisJob.star]);\n  if (Ctl.hasProgram(\"console\")) {\n    console.log(\"starting console for app\", Ctl.myAppName());\n    Ctl.startServerlikeProgramIfNotPresent(\"console\", [\"admin\"], true);\n  }\n  console.log(\"starting server for app\", Ctl.myAppName());\n  Ctl.startServerlikeProgramIfNotPresent(\"server\", [\"runner\"]);\n};\n\nCtl.Commands.push({\n  name: \"start\",\n  help: \"Start this app\",\n  func: startFun\n});\n\n\nCtl.Commands.push({\n  name: \"endUpdate\",\n  help: \"Start this app to end an update\",\n  func: startFun\n});\n\nvar stopFun =  function (argv) {\n  if (argv.help || argv._.length !== 0) {\n    process.stderr.write(\n      \"Usage: ctl stop\\n\" +\n        \"\\n\" +\n        \"Stops the app. For now, this just means that it kills all jobs\\n\" +\n        \"other than itself.\\n\"\n    );\n    process.exit(1);\n  }\n\n  // Get all jobs (other than this job: don't commit suicide!) that are not\n  // already killed.\n  var jobs = Ctl.getJobsByApp(\n    Ctl.myAppName(), {_id: {$ne: Ctl.myJobId()}, done: false});\n  jobs.forEach(function (job) {\n    // Don't commit suicide.\n    if (job._id === Ctl.myJobId())\n      return;\n    // It's dead, Jim.\n    if (job.done)\n      return;\n    Ctl.kill(job.program, job._id);\n  });\n  console.log(\"Server stopped.\");\n};\n\nCtl.Commands.push({\n  name: \"stop\",\n  help: \"Stop this app\",\n  func: stopFun\n});\n\nvar waitForDone = function (jobCollection, jobId) {\n  var fut = new Future();\n  var found = false;\n  try {\n    var observation = jobCollection.find(jobId).observe({\n      added: function (doc) {\n        found = true;\n        if (doc.done)\n          fut['return']();\n      },\n      changed: function (doc) {\n        if (doc.done)\n          fut['return']();\n      },\n      removed: function (doc) {\n        fut['return']();\n      }\n    });\n    // if the document doesn't exist at all, it's certainly done.\n    if (!found)\n      fut['return']();\n    fut.wait();\n  } finally {\n    observation.stop();\n  }\n};\n\n\nCtl.Commands.push({\n  name: \"beginUpdate\",\n  help: \"Stop this app to begin an update\",\n  func: function (argv) {\n    Ctl.subscribeToAppJobs(Ctl.myAppName());\n    var jobs = Ctl.jobsCollection();\n    var thisJob = jobs.findOne(Ctl.myJobId());\n    // Look at all the server jobs that are on the old star.\n    var oldJobSelector = {\n      app: Ctl.myAppName(),\n      star: {$ne: thisJob.star},\n      program: \"server\",\n      done: false\n    };\n    var oldServers = jobs.find(oldJobSelector).fetch();\n    // Start a new job for each of them.\n    var newServersAlreadyPresent = jobs.find({\n      app: Ctl.myAppName(),\n      star: thisJob.star,\n      program: \"server\",\n      done: false\n    }).count();\n    // discount any new servers we've already started.\n    oldServers.splice(0, newServersAlreadyPresent);\n    console.log(\"starting \" + oldServers.length + \" new servers to match old\");\n    _.each(oldServers, function (oldServer) {\n      Ctl.startServerlikeProgram(\"server\",\n                                 oldServer.tags,\n                                 oldServer.env.ADMIN_APP);\n    });\n    // Wait for them all to come up and bind to the proxy.\n    var updateProxyActiveTagsOptions = {\n      requireRegisteredBindingCount: {}\n    };\n    // How many new servers should be up when we update the tags, given how many\n    // servers we're aiming at:\n    var target;\n    switch (oldServers.length) {\n    case 0:\n      target = 0;\n      break;\n    case 1:\n      target = 1;\n      break;\n    case 2:\n      target = 1;\n      break;\n    default:\n      var c = oldServers.length;\n      target =  Math.min(c - 1, Math.ceil(c*.8));\n      break;\n    }\n    updateProxyActiveTagsOptions.requireRegisteredBindingCount[thisJob.star] =\n      target;\n    Ctl.updateProxyActiveTags(['', thisJob.star], updateProxyActiveTagsOptions);\n\n    // (eventually) tell the proxy to switch over to using the new star\n    // One by one, kill all the old star's server jobs.\n    var jobToKill = jobs.findOne(oldJobSelector);\n    while (jobToKill) {\n      Ctl.kill(\"server\", jobToKill._id);\n      // Wait for it to go down\n      waitForDone(jobs, jobToKill._id);\n      // Spend some time in between to allow any reconnect storm to die down.\n      Meteor._sleepForMs(5000);\n      jobToKill = jobs.findOne(oldJobSelector);\n    }\n    // Now kill all old non-server jobs.  They're less important.\n    jobs.find({\n      app: Ctl.myAppName(),\n      star: {$ne: thisJob.star},\n      program: {$ne: \"server\"},\n      done: false\n    }).forEach(function (job) {\n      Ctl.kill(job.program, job._id);\n    });\n    // fin\n    process.exit(0);\n  }\n});\n\nmain = function (argv) {\n  return Ctl.main(argv);\n};\n"]}