)]}'
{"version":3,"file":"/packages/domutils.js","sources":["domutils/domutils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,6D;AACA,yD;AACA,yC;AACA,kC;AACA,sE;;AAEA,4D;AACA,kD;AACA,6B;;AAEA,uB;AACA,oD;AACA,2B;AACA,+D;AACA,2C;AACA,0E;AACA,wC;AACA,mB;AACA,yD;AACA,O;AACA,E;;AAEA,mE;AACA,qE;AACA,E;AACA,6E;AACA,yE;AACA,oC;AACA,gC;AACA,E;AACA,qB;AACA,sC;AACA,iE;AACA,kD;;AAEA,yD;;AAEA,4C;AACA,wE;AACA,sE;AACA,oB;AACA,kD;AACA,2E;AACA,wD;;AAEA,wD;AACA,c;AACA,wD;AACA,+D;;AAEA,iD;AACA,mE;;AAEA,uE;AACA,8D;;AAEA,+D;AACA,yE;;AAEA,6E;;AAEA,wE;AACA,sE;AACA,+B;AACA,yC;AACA,kE;AACA,E;;AAEA,8C;AACA,e;AACA,6D;AACA,6C;AACA,sC;AACA,kD;AACA,2D;AACA,wE;AACA,iC;AACA,yB;AACA,E;AACA,mB;AACA,2B;AACA,uB;AACA,uB;AACA,0B;AACA,yB;AACA,gB;AACA,G;AACA,sB;AACA,wE;AACA,iD;AACA,C;;AAEA,gC;AACA,0F;AACA,2B;AACA,uB;AACA,wB;AACA,wC;;;AAGA,mE;AACA,iC;AACA,2C;AACA,qC;AACA,0C;;AAEA,sB;AACA,wB;AACA,kC;AACA,iB;AACA,+C;AACA,U;AACA,oB;AACA,gC;AACA,gD;AACA,kD;AACA,4C;AACA,yE;AACA,yD;AACA,oD;AACA,8B;AACA,0D;AACA,4D;AACA,mE;AACA,8D;AACA,2C;AACA,K;;AAEA,6C;AACA,qC;AACA,mC;AACA,+C;AACA,8B;AACA,uB;AACA,sC;AACA,K;;AAEA,uD;AACA,sD;AACA,4D;AACA,oC;AACA,6B;AACA,iC;AACA,sC;AACA,S;AACA,S;AACA,K;;AAEA,yC;AACA,kD;AACA,oB;AACA,8D;AACA,qD;AACA,O;AACA,K;;AAEA,8B;AACA,yD;AACA,wB;AACA,mE;AACA,oE;AACA,iB;AACA,mE;AACA,oE;AACA,sD;AACA,6B;AACA,S;AACA,S;;AAEA,2C;AACA,kE;AACA,gD;AACA,2C;AACA,oE;AACA,wD;AACA,+F;AACA,kE;AACA,+C;AACA,2D;AACA,S;AACA,sD;AACA,uD;AACA,4E;AACA,yE;AACA,qD;AACA,2C;AACA,oD;AACA,2C;AACA,mC;AACA,mD;AACA,+C;AACA,4E;AACA,4C;AACA,oD;AACA,iC;AACA,8C;AACA,W;AACA,S;;AAEA,4B;AACA,kC;AACA,kD;AACA,kB;AACA,0D;AACA,S;AACA,K;;AAEA,8C;AACA,gC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,2D;AACA,2D;AACA,yC;AACA,2C;AACA,kE;;AAEA,sD;AACA,E;;AAEA,iE;AACA,mE;AACA,gE;AACA,oE;AACA,gC;AACA,gD;AACA,qC;;AAEA,qC;AACA,uD;AACA,4C;AACA,G;;AAEA,2C;;AAEA,uB;AACA,e;AACA,gC;AACA,U;AACA,yC;AACA,yD;;AAEA,oD;AACA,8B;AACA,uB;AACA,sC;AACA,K;;AAEA,gC;AACA,G;;AAEA,mB;AACA,E;;AAEA,+D;AACA,4C;AACA,qC;AACA,iB;AACA,c;AACA,iB;;AAEA,kC;AACA,+C;AACA,U;AACA,+D;AACA,0E;AACA,gE;AACA,yC;AACA,qB;AACA,gD;AACA,mB;AACA,gB;AACA,kB;;AAEA,yB;AACA,G;AACA,E;;AAEA,+D;AACA,2D;AACA,iE;AACA,6D;AACA,+D;AACA,mE;AACA,6D;AACA,U;AACA,E;AACA,yE;AACA,qD;AACA,2D;AACA,yC;AACA,M;AACA,wE;AACA,sE;AACA,sE;AACA,uE;AACA,uB;AACA,2B;AACA,uD;AACA,yD;AACA,+B;AACA,gC;AACA,6C;AACA,mB;AACA,G;;AAEA,kD;AACA,E;;AAEA,0D;AACA,kD;AACA,wD;AACA,8C;AACA,E;;AAEA,gE;AACA,4D;AACA,gD;AACA,iB;AACA,0D;AACA,gE;AACA,uD;AACA,E;;AAEA,8D;AACA,sE;AACA,oE;AACA,qE;AACA,qE;AACA,iE;AACA,E;AACA,sE;AACA,uC;AACA,E;AACA,4D;AACA,e;AACA,gF;;AAEA,8E;AACA,0E;AACA,2B;AACA,2D;AACA,sC;AACA,yD;AACA,sC;AACA,+B;AACA,+E;;AAEA,yE;AACA,mD;AACA,4D;;AAEA,qE;AACA,kB;AACA,6C;AACA,yD;AACA,K;AACA,E;;AAEA,iE;AACA,6E;AACA,wC;AACA,+C;AACA,8C;AACA,E;;AAEA,yE;AACA,4D;AACA,sE;AACA,uD;AACA,uB;AACA,qC;AACA,wC;AACA,oB;AACA,G;AACA,O;AACA,yE;AACA,gD;AACA,a;AACA,iB;AACA,oC;AACA,G;AACA,E;;AAEA,2E;AACA,gE;AACA,mC;AACA,iD;AACA,gC;AACA,iD;AACA,6B;AACA,iE;AACA,yE;AACA,wE;AACA,gC;AACA,4D;AACA,mB;AACA,sB;AACA,sE;AACA,4D;AACA,Y;AACA,gE;AACA,oC;AACA,S;;AAEA,gB;AACA,kB;AACA,G;;AAEA,e;AACA,E;;AAEA,kE;AACA,sE;AACA,qE;AACA,E;;AAEA,kE;AACA,sD;AACA,2E;AACA,iE;AACA,oE;AACA,yD;AACA,E;;AAEA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,gD;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,0D;AACA,iE;AACA,oE;AACA,8B;AACA,E;AACA,uD;AACA,uC;AACA,gE;AACA,oD;AACA,4B;AACA,4D;AACA,wD;AACA,+D;AACA,yD;AACA,qB;AACA,gD;AACA,4B;AACA,4B;AACA,G;AACA,E;;AAEA,iE;AACA,oE;AACA,mE;AACA,iE;AACA,yC;AACA,E;AACA,qC;AACA,yC;AACA,qD;AACA,2C;AACA,wB;AACA,gB;;AAEA,wC;AACA,2B;AACA,sC;AACA,iB;AACA,6B;AACA,gB;;AAEA,uD;AACA,E;;AAEA,yD;AACA,iD;AACA,6D;AACA,0C;AACA,uD;AACA,+C;AACA,sD;AACA,uB;AACA,wB;AACA,qD;AACA,uC;AACA,E;;AAEA,8D;AACA,0B;AACA,sC;AACA,0C;AACA,E;;AAEA,4E;AACA,kC;AACA,mD;AACA,6B;AACA,qB;AACA,yD;AACA,W;;AAEA,yE;AACA,wE;AACA,2E;AACA,8B;AACA,iD;AACA,4C;AACA,yD;AACA,iC;AACA,a;AACA,K;AACA,G;AACA,E;;AAEA,4E;AACA,kC;AACA,4C;AACA,6C;AACA,sB;;AAEA,mC;AACA,8C;AACA,oC;AACA,0D;AACA,0C;AACA,+B;AACA,kB;AACA,sE;AACA,U;AACA,sB;AACA,G;AACA,E","sourcesContent":["DomUtils = {};\n\nvar qsaFindAllBySelector = function (selector, contextNode) {\n  // If IE7 users report the following error message, you\n  // can fix it with \"meteor add jquery\".\n  if (! document.querySelectorAll)\n    throw new Error(\"This browser doesn't support querySelectorAll.\");\n\n  // the search is constrained to descendants of `ancestor`,\n  // but it doesn't affect the scope of the query.\n  var ancestor = contextNode;\n\n  return withElementId(\n    contextNode, \"DomUtils_findAllBySelector_scope\",\n    function (idSelector) {\n      // scope the entire selector to contextNode by prepending\n      // id of contextNode to the selector.\n      var doctoredSelector = _.map(selector.split(','), function (selec) {\n        return idSelector + \" \" + selec;\n      }).join(',');\n      return ancestor.querySelectorAll(doctoredSelector);\n    });\n};\n\n// We have our own, querySelectorAll-based implementation of scoped\n// selector matching; it's all you need in IE 8+ and modern browsers.\n//\n// However, we use Sizzle or jQuery if it's present on the client because of:\n// - apps that want jQuery's selector extensions (:visible, :input, etc.)\n// - apps that include jQuery anyway\n// - apps that want IE 7 support\n//\n// XXX others? zepto?\nvar findAllBySelector = (window.Sizzle\n                         || (window.jQuery && window.jQuery.find)\n                         || qsaFindAllBySelector);\n\n///// Common look-up tables used by htmlToFragment et al.\n\nvar testDiv = document.createElement(\"div\");\ntestDiv.innerHTML = \"   <link/><table></table><select><!----></select>\";\n// Need to wrap in a div rather than directly creating SELECT to avoid\n// *another* IE bug.\nvar testSelectDiv = document.createElement(\"div\");\ntestSelectDiv.innerHTML = \"<select><option selected>Foo</option></select>\";\ntestSelectDiv.firstChild.setAttribute(\"name\", \"myname\");\n\n// Tests that, if true, indicate browser quirks present.\nvar quirks = {\n  // IE loses initial whitespace when setting innerHTML.\n  leadingWhitespaceKilled: (testDiv.firstChild.nodeType !== 3),\n\n  // IE may insert an empty tbody tag in a table.\n  tbodyInsertion: testDiv.getElementsByTagName(\"tbody\").length > 0,\n\n  // IE loses some tags in some environments (requiring extra wrapper).\n  tagsLost: testDiv.getElementsByTagName(\"link\").length === 0,\n\n  // IE <= 9 loses HTML comments in <select> and <option> tags.\n  commentsLost: (! testDiv.getElementsByTagName(\"select\")[0].firstChild),\n\n  selectValueMustBeFromAttribute: (testSelectDiv.firstChild.value !== \"Foo\"),\n\n  // In IE7, setAttribute('name', foo) doesn't show up in rendered HTML.\n  // (In FF3, outerHTML is undefined, but it doesn't have this quirk.)\n  mustSetNameInCreateElement: (\n    testSelectDiv.firstChild.outerHTML &&\n      testSelectDiv.firstChild.outerHTML.indexOf(\"myname\") === -1)\n};\n\n// Set up map of wrappers for different nodes.\nvar wrapMap = {\n  option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n  legend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n  thead: [ 1, \"<table>\", \"</table>\" ],\n  tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n  td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n  col: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n  area: [ 1, \"<map>\", \"</map>\" ],\n  _default: [ 0, \"\", \"\" ]\n};\n_.extend(wrapMap, {\n  optgroup: wrapMap.option,\n  tbody: wrapMap.thead,\n  tfoot: wrapMap.thead,\n  colgroup: wrapMap.thead,\n  caption: wrapMap.thead,\n  th: wrapMap.td\n});\nif (quirks.tagsLost) {\n  // trick from jquery.  initial text is ignored when we take lastChild.\n  wrapMap._default = [ 1, \"div<div>\", \"</div>\" ];\n}\n\nvar rleadingWhitespace = /^\\s+/,\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rtagName = /<([\\w:]+)/,\n    rtbody = /<tbody/i,\n    rhtml = /<|&#?\\w+;/,\n    rnoInnerhtml = /<(?:script|style)/i;\n\n\n// Parse an HTML string, which may contain multiple top-level tags,\n// and return a DocumentFragment.\nDomUtils.htmlToFragment = function (html) {\n  var doc = document; // node factory\n  var frag = doc.createDocumentFragment();\n\n  if (! html.length) {\n    // empty, do nothing\n  } else if (! rhtml.test(html)) {\n    // Just text.\n    frag.appendChild(doc.createTextNode(html));\n  } else {\n    // General case.\n    // Replace self-closing tags\n    html = html.replace(rxhtmlTag, \"<$1></$2>\");\n    // Use first tag to determine wrapping needed.\n    var firstTagMatch = rtagName.exec(html);\n    var firstTag = (firstTagMatch ? firstTagMatch[1].toLowerCase() : \"\");\n    var wrapData = wrapMap[firstTag] || wrapMap._default;\n    var fullHtml = wrapData[1] + html + wrapData[2];\n    if (quirks.commentsLost) {\n      // rewrite <select> and <option> tags into fake tags\n      fullHtml = fullHtml.replace(/<\\s*(select|option)\\b/ig,\n                                  '<ins domutilsrealtagname=\"$1\"');\n      fullHtml = fullHtml.replace(/<\\/\\s*(select|option)\\b/ig,\n                                  '</ins');\n    }\n\n    var container = doc.createElement(\"div\");\n    // insert wrapped HTML into a DIV\n    container.innerHTML = fullHtml;\n    // set \"container\" to inner node of wrapper\n    var unwraps = wrapData[0];\n    while (unwraps--) {\n      container = container.lastChild;\n    }\n\n    if (quirks.tbodyInsertion && ! rtbody.test(html)) {\n      // Any tbody we find was created by the browser.\n      var tbodies = container.getElementsByTagName(\"tbody\");\n      _.each(tbodies, function (n) {\n        if (! n.firstChild) {\n          // spurious empty tbody\n          n.parentNode.removeChild(n);\n        }\n      });\n    }\n\n    if (quirks.leadingWhitespaceKilled) {\n      var wsMatch = rleadingWhitespace.exec(html);\n      if (wsMatch) {\n        container.insertBefore(doc.createTextNode(wsMatch[0]),\n                               container.firstChild);\n      }\n    }\n\n    if (quirks.commentsLost) {\n      // replace fake select tags with real <select> tags\n      var fakeTags = [];\n      // getElementsByTagName returns a \"live\" collection, so avoid\n      // factorings of this code that iterate over it while mutating\n      // the DOM.\n      // Here we build an array of fake tags and iterate over that.\n      _.each(container.getElementsByTagName(\"ins\"), function (ins) {\n        if (ins.getAttribute(\"domutilsrealtagname\")) {\n          fakeTags.push(ins);\n        }\n      });\n\n      _.each(fakeTags, function (fakeTag) {\n        var tagName = fakeTag.getAttribute('domutilsrealtagname');\n        if (quirks.mustSetNameInCreateElement &&\n            fakeTag.getAttribute('name')) {\n          // IE7 can't set 'name' with setAttribute, but it has this\n          // crazy syntax for setting it at create time.\n          // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html\n          // http://msdn.microsoft.com/en-us/library/ms536389.aspx\n          tagName = \"<\" + tagName + \" name='\" +\n            _.escape(fakeTag.getAttribute('name')) + \"'/>\";\n        }\n        var realTag = document.createElement(tagName);\n        fakeTag.removeAttribute('domutilsrealtagname');\n        // copy all attributes. for some reason mergeAttributes doesn't work\n        // here: eg, it doesn't copy SELECTED or VALUE. (Probably because\n        // these attributes would be expando on INS?)\n        var fakeAttrs = fakeTag.attributes;\n        for (var i = 0; i < fakeAttrs.length; ++i) {\n          var fakeAttr = fakeAttrs.item(i);\n          if (fakeAttr.specified) {\n            var name = fakeAttr.name.toLowerCase();\n            var value = String(fakeAttr.value);\n            // IE7 gets confused if you try to setAttribute('selected', ''),\n            // so be a little more explicit.\n            if (name === 'selected' && value === '')\n              value = 'selected';\n            realTag.setAttribute(name, value);\n          }\n        }\n\n        // move all children\n        while (fakeTag.firstChild)\n          realTag.appendChild(fakeTag.firstChild);\n        // replace\n        fakeTag.parentNode.replaceChild(realTag, fakeTag);\n      });\n    }\n\n    // Reparent children of container to frag.\n    while (container.firstChild)\n      frag.appendChild(container.firstChild);\n  }\n\n  return frag;\n};\n\n// Return an HTML string representing the contents of frag,\n// a DocumentFragment.  (This is what innerHTML would do if\n// it were defined on DocumentFragments.)\nDomUtils.fragmentToHtml = function (frag) {\n  frag = frag.cloneNode(true); // deep copy, don't touch original!\n\n  return DomUtils.fragmentToContainer(frag).innerHTML;\n};\n\n// Given a DocumentFragment, return a node whose children are the\n// reparented contents of the DocumentFragment.  In most cases this\n// is as simple as creating a DIV, but in the case of a fragment\n// containing TRs, for example, it's necessary to create a TABLE and\n// a TBODY and return the TBODY.\nDomUtils.fragmentToContainer = function (frag) {\n  var doc = document; // node factory\n\n  var firstElement = frag.firstChild;\n  while (firstElement && firstElement.nodeType !== 1) {\n    firstElement = firstElement.nextSibling;\n  }\n\n  var container = doc.createElement(\"div\");\n\n  if (! firstElement) {\n    // no tags!\n    container.appendChild(frag);\n  } else {\n    var firstTag = firstElement.nodeName;\n    var wrapData = wrapMap[firstTag] || wrapMap._default;\n\n    container.innerHTML = wrapData[1] + wrapData[2];\n    var unwraps = wrapData[0];\n    while (unwraps--) {\n      container = container.lastChild;\n    }\n\n    container.appendChild(frag);\n  }\n\n  return container;\n};\n\n// Returns true if element a contains node b and is not node b.\nDomUtils.elementContains = function (a, b) {\n  if (a.nodeType !== 1) /* ELEMENT */\n    return false;\n  if (a === b)\n    return false;\n\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (! (b && b.nodeType === 1)) /* ELEMENT */\n      return false;\n    if (a === b)\n      return true;\n\n    return a.contains(b);\n  }\n};\n\n// Returns an array containing the children of contextNode that\n// match `selector`. Unlike querySelectorAll, `selector` is\n// interpreted as if the document were rooted at `contextNode` --\n// the only nodes that can be used to match components of the\n// selector are the descendents of `contextNode`. `contextNode`\n// itself is not included (it can't be used to match a component of\n// the selector, and it can never be included in the returned\n// array.)\n//\n// `contextNode` may be either a node, a document, or a DocumentFragment.\nDomUtils.findAll = function (contextNode, selector) {\n  if (contextNode.nodeType === 11 /* DocumentFragment */) {\n    // contextNode is a DocumentFragment.\n    //\n    // We don't expect to be able to run selectors on a DocumentFragment\n    // (Sizzle won't work) but we can on a normal elements that aren't\n    // in the document.  Fortunately we can manipulate offscreen nodes\n    // as much as we want as long as we put them back the way they were\n    // when we're done.\n    var frag = contextNode;\n    var container = DomUtils.fragmentToContainer(frag);\n    var results = findAllBySelector(selector, container);\n    // put nodes back into frag\n    while (container.firstChild)\n      frag.appendChild(container.firstChild);\n    return results;\n  }\n\n  return findAllBySelector(selector, contextNode);\n};\n\n// Like `findAll` but finds one element (or returns null).\nDomUtils.find = function (contextNode, selector) {\n  var results = DomUtils.findAll(contextNode, selector);\n  return (results.length ? results[0] : null);\n};\n\nvar isElementInClipRange = function (elem, clipStart, clipEnd) {\n  // elem is not in clip range if it contains the clip range\n  if (DomUtils.elementContains(elem, clipStart))\n    return false;\n  // elem is in clip range if clipStart <= elem <= clipEnd\n  return (DomUtils.compareElementIndex(clipStart, elem) <= 0) &&\n    (DomUtils.compareElementIndex(elem, clipEnd) <= 0);\n};\n\n// Like `findAll` but searches the nodes from `start` to `end`\n// inclusive. `start` and `end` must be siblings, and they participate\n// in the search (they can be used to match selector components, and\n// they can appear in the returned results). It's as if the parent of\n// `start` and `end` serves as contextNode, but matches from children\n// that aren't between `start` and `end` (inclusive) are ignored.\n//\n// If `selector` involves sibling selectors, child index selectors, or\n// the like, the results are undefined.\n//\n// precond: clipStart/clipEnd are descendents of contextNode\n// XXX document\nDomUtils.findAllClipped = function (contextNode, selector, clipStart, clipEnd) {\n\n  // Ensure the clip range starts and ends on element nodes.  This is possible\n  // to do without changing the result set because non-element nodes can't\n  // be or contain matches.\n  while (clipStart !== clipEnd && clipStart.nodeType !== 1)\n    clipStart = clipStart.nextSibling;\n  while (clipStart !== clipEnd && clipEnd.nodeType !== 1)\n    clipEnd = clipEnd.previousSibling;\n  if (clipStart.nodeType !== 1)\n    return []; // no top-level elements!  start === end and it's not an element\n\n  // resultsPlus includes matches all matches descended from contextNode,\n  // including those that aren't in the clip range.\n  var resultsPlus = DomUtils.findAll(contextNode, selector);\n\n  // Filter the list of nodes to remove nodes that occur before start\n  // or after end.\n  return _.reject(resultsPlus, function (n) {\n    return ! isElementInClipRange(n, clipStart, clipEnd);\n  });\n};\n\n// Like `findAllClipped` but finds one element (or returns null).\nDomUtils.findClipped = function (contextNode, selector, clipStart, clipEnd) {\n  var results = DomUtils.findAllClipped(\n    contextNode, selector, clipStart, clipEnd);\n  return (results.length ? results[0] : null);\n};\n\n// Executes `func` while ensuring that `element` has an ID.  If `element`\n// doesn't have an ID, it is assigned `magicId` temporarily.\n// Calls func with a selector of the form \"[id='...']\" as an argument.\nvar withElementId = function (element, magicId, func) {\n  var didSetId = false;\n  if (! element.getAttribute('id')) {\n    element.setAttribute('id', magicId);\n    didSetId = true;\n  }\n  try {\n    var escapedNodeId = element.getAttribute('id').replace(/'/g, \"\\\\$&\");\n    return func(\"[id='\" + escapedNodeId + \"']\");\n  } finally {\n    if (didSetId)\n      element.removeAttribute('id');\n  }\n};\n\nvar matchesSelectorMaybeClipped = function (element, contextNode, selector,\n                                           clipStart, clipEnd) {\n  var selecs = selector.split(',');\n  for(var i = 0, N = selecs.length; i < N; i++) {\n    var matches = withElementId(\n      element, \"DomUtils_matchesSelector_target\",\n      function (idSelector) {\n        var trimmedSelector = selector.match(/\\S.*?(?=\\s*$)/)[0];\n        // appending [id='foo'] to a selector with no whitespace ought to\n        // simply restrict the set of possible outputs regardless of the\n        // form of the selector.\n        var doctoredSelector = trimmedSelector + idSelector;\n        var result;\n        if (clipStart)\n          result = DomUtils.findClipped(contextNode, doctoredSelector,\n                                        clipStart, clipEnd);\n        else\n          result = DomUtils.find(contextNode, doctoredSelector);\n        return (result === element);\n      });\n\n    if (matches)\n      return true;\n  }\n\n  return false;\n};\n\n// Check if `element` matches `selector`, scoped to `contextNode`.\nDomUtils.matchesSelector = function (element, contextNode, selector) {\n  return matchesSelectorMaybeClipped(element, contextNode, selector);\n};\n\n// Check if `element` matches `selector`, scoped to `contextNode`,\n// clipped to ordered siblings `clipStart`..`clipEnd`.\nDomUtils.matchesSelectorClipped = function (element, contextNode, selector,\n                                            clipStart, clipEnd) {\n  return matchesSelectorMaybeClipped(element, contextNode, selector,\n                                     clipStart, clipEnd);\n};\n\n// Returns 0 if the nodes are the same or either one contains the other;\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\n// document order.\n// Requires: `a` and `b` are element nodes in the same document tree.\nDomUtils.compareElementIndex = function (a, b) {\n  // See http://ejohn.org/blog/comparing-document-position/\n  if (a === b)\n    return 0;\n  if (a.compareDocumentPosition) {\n    var n = a.compareDocumentPosition(b);\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\n  } else {\n    // Only old IE is known to not have compareDocumentPosition (though Safari\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\n    // via the \"sourceIndex\" property.\n    if (a.contains(b) || b.contains(a))\n      return 0;\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\n  }\n};\n\n// Wrap `frag` as necessary to prepare it for insertion in\n// `container`. For example, if `frag` has TR nodes at top level,\n// and `container` is a TABLE, then it's necessary to wrap `frag` in\n// a TBODY to avoid IE quirks.\n//\n// `frag` is a DocumentFragment and will be modified in\n// place. `container` is a DOM element.\nDomUtils.wrapFragmentForContainer = function (frag, container) {\n  if (container && container.nodeName === \"TABLE\" &&\n      _.any(frag.childNodes,\n            function (n) { return n.nodeName === \"TR\"; })) {\n    // Avoid putting a TR directly in a TABLE without an\n    // intervening TBODY, because it doesn't work in IE.  We do\n    // the same thing on all browsers for ease of testing\n    // and debugging.\n    var tbody = document.createElement(\"TBODY\");\n    tbody.appendChild(frag);\n    frag.appendChild(tbody);\n  }\n};\n\n// Return true if `node` is part of the global DOM document. Like\n// elementContains(document, node), except (1) it works for any node\n// (eg, text nodes), not just elements; (2) it works around browser\n// quirks that would otherwise come up when passing 'document' as\n// the first argument to elementContains.\n//\n// Returns true if node === document.\nDomUtils.isInDocument = function (node) {\n  // Deal with all cases where node is not an element\n  // node descending from the body first...\n  if (node === document)\n    return true;\n\n  if (node.nodeType !== 1 /* Element */)\n    node = node.parentNode;\n  if (! (node && node.nodeType === 1))\n    return false;\n  if (node === document.body)\n    return true;\n\n  return DomUtils.elementContains(document.body, node);\n};\n\n// Return an HTML string representation of the nodes from\n// firstNode to lastNode, which must be siblings.\n// The tags representing firstNode and lastNode are included,\n// but not their parent or outer siblings.\nDomUtils.rangeToHtml = function (firstNode, lastNode) {\n  var frag = document.createDocumentFragment();\n  for(var n = firstNode, after = lastNode.nextSibling;\n      n && n !== after;\n      n = n.nextSibling)\n    frag.appendChild(n.cloneNode(true)); // deep copy\n  return DomUtils.fragmentToHtml(frag);\n};\n\n// Return an HTML string representation of node, including its\n// own open and close tag.\nDomUtils.outerHtml = function (node) {\n  return DomUtils.rangeToHtml(node, node);\n};\n\n// Sets the value of an element, portably across browsers. There's a special\n// case for SELECT elements in IE.\nDomUtils.setElementValue = function (node, value) {\n  // Try to assign the value.\n  node.value = value;\n  if (node.value === value || node.nodeName !== 'SELECT')\n    return;\n\n  // IE (all versions) appears to only let you assign SELECT values which\n  // match valid OPTION values... and moreover, the OPTION value must be\n  // explicitly given as an attribute, not just as the text. So we hunt for\n  // the OPTION and select it.\n  var options = DomUtils.findAll(node, 'option');\n  for (var i = 0; i < options.length; ++i) {\n    if (DomUtils.getElementValue(options[i]) === value) {\n      options[i].selected = true;\n      return;\n    }\n  }\n};\n\n// Gets the value of an element, portably across browsers. There's a special\n// case for SELECT elements in IE.\nDomUtils.getElementValue = function (node) {\n  if (!quirks.selectValueMustBeFromAttribute)\n    return node.value;\n\n  if (node.nodeName === 'OPTION') {\n    // Inspired by jQuery.valHooks.option.get.\n    var val = node.attributes.value;\n    return !val || val.specified ? node.value : node.text;\n  } else if (node.nodeName === 'SELECT') {\n    if (node.selectedIndex < 0)\n      return null;\n    return DomUtils.getElementValue(node.options[node.selectedIndex]);\n  } else {\n    return node.value;\n  }\n};\n"]}