)]}'
{"version":3,"file":"/packages/accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/url_client.js","accounts-base/accounts_client.js","accounts-base/localstorage_token.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;AACA,E;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,8D;AACA,oE;AACA,yC;AACA,yC;AACA,wB;AACA,uF;AACA,sC;AACA,2F;AACA,gF;AACA,gD;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,sB;AACA,uE;AACA,+D;AACA,uE;AACA,I;AACA,sE;AACA,4D;AACA,6B;AACA,0C;;AAEA,yD;AACA,0D;AACA,uE;AACA,+D;AACA,kE;AACA,gE;AACA,M;AACA,mE;AACA,4D;AACA,sC;AACA,wD;AACA,G;AACA,C;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,+C;AACA,4B;AACA,uE;AACA,G;AACA,gE;AACA,c;;AAEA,uF;AACA,4B;AACA,4B;AACA,0D;AACA,2E;AACA,0D;AACA,G;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACtKA,wB;;AAEA,qE;AACA,kE;AACA,mE;AACA,S;AACA,E;AACA,oE;AACA,qE;AACA,sB;AACA,U;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;AAEA,8D;AACA,gE;AACA,wB;AACA,E;AACA,mE;AACA,oE;AACA,+D;AACA,+D;AACA,kE;AACA,2C;AACA,+D;AACA,Y;AACA,2B;AACA,wC;AACA,4B;AACA,C;;AAEA,qE;AACA,gE;AACA,wB;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;;;;;;;;;;;;;;;;;;AC3CA,G;AACA,gB;AACA,G;;AAEA,oB;AACA,6B;AACA,sC;AACA,E;;AAEA,sB;AACA,wC;AACA,4E;AACA,4E;AACA,mB;AACA,uC;AACA,wB;AACA,kB;AACA,4B;AACA,G;AACA,E;AACA,gC;AACA,yB;AACA,mB;AACA,E;;AAEA,wC;AACA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,iB;AACA,G;;AAEA,qC;AACA,E;AACA,6E;AACA,4E;AACA,0E;AACA,6B;AACA,E;AACA,+B;AACA,2D;AACA,wC;AACA,0D;AACA,0D;AACA,2D;AACA,uB;AACA,E;AACA,W;AACA,qD;AACA,kD;AACA,uE;AACA,8E;AACA,6D;AACA,0E;AACA,yD;AACA,E;AACA,+C;AACA,sB;AACA,wB;AACA,wB;AACA,6B;AACA,c;AACA,yE;AACA,gC;AACA,2D;AACA,oB;AACA,kC;AACA,K;AACA,qD;AACA,sD;;AAEA,0B;;AAEA,6E;AACA,2E;AACA,0E;AACA,wE;AACA,2E;AACA,yE;AACA,yE;AACA,0C;AACA,I;AACA,0E;AACA,4E;AACA,4E;AACA,2E;AACA,gE;AACA,iD;AACA,0C;AACA,6C;AACA,Y;AACA,qD;AACA,2B;AACA,mE;AACA,6C;AACA,0B;AACA,oB;AACA,+B;AACA,mD;AACA,Y;AACA,S;AACA,kC;AACA,sE;AACA,8D;AACA,gC;AACA,gB;AACA,oC;AACA,sD;AACA,wE;AACA,+E;AACA,mD;AACA,qC;AACA,4C;AACA,sD;AACA,0B;AACA,8E;AACA,2E;AACA,6E;AACA,6E;AACA,+E;AACA,gF;AACA,6E;AACA,8E;AACA,6E;AACA,gF;AACA,gF;AACA,kB;AACA,8E;AACA,gF;AACA,0E;AACA,6E;AACA,0E;AACA,wE;AACA,wC;AACA,iB;AACA,e;AACA,8E;AACA,+E;AACA,wB;AACA,sC;AACA,gB;AACA,S;AACA,Q;AACA,K;AACA,I;;AAEA,qE;AACA,6E;AACA,U;AACA,+D;AACA,wE;AACA,2E;AACA,2E;AACA,yD;AACA,0E;AACA,oB;AACA,a;;AAEA,yE;AACA,gE;AACA,iD;AACA,kC;AACA,2B;AACA,iC;AACA,wD;AACA,8B;AACA,a;AACA,K;AACA,S;AACA,qC;AACA,iB;AACA,0B;AACA,a;AACA,K;;AAEA,2E;AACA,qE;AACA,uB;AACA,I;;AAEA,kC;AACA,iC;AACA,4B;AACA,uB;AACA,4B;AACA,qD;AACA,kC;AACA,E;;AAEA,kC;AACA,sB;AACA,sC;AACA,yC;AACA,E;;AAEA,4D;AACA,+C;AACA,wC;AACA,E;;AAEA,qC;AACA,iF;AACA,gB;AACA,kC;AACA,Y;AACA,4B;AACA,6B;AACA,K;AACA,K;AACA,E;;AAEA,iD;AACA,wE;AACA,wE;AACA,kE;AACA,sE;AACA,uE;AACA,uE;AACA,+D;AACA,qE;AACA,+B;AACA,I;AACA,sE;AACA,qE;AACA,6D;AACA,uE;AACA,wE;AACA,2B;AACA,4B;AACA,kB;AACA,O;AACA,mB;AACA,4B;AACA,kB;AACA,4E;AACA,O;AACA,K;AACA,I;AACA,4B;AACA,wB;AACA,O;AACA,mB;AACA,oB;AACA,gC;AACA,K;AACA,I;AACA,E;;;AAGA,G;AACA,kB;AACA,G;;AAEA,yB;AACA,oE;;AAEA,sE;AACA,sE;AACA,6C;AACA,E;AACA,gD;AACA,qC;AACA,E;;AAEA,G;AACA,sB;AACA,G;;AAEA,sE;AACA,kB;AACA,iB;AACA,2D;AACA,yB;AACA,K;AACA,yD;AACA,8B;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;AC1RA,gE;AACA,oE;AACA,uE;AACA,W;;AAEA,6B;;AAEA,qE;AACA,Q;AACA,oD;AACA,4B;AACA,uC;AACA,6B;AACA,E;;AAEA,sE;AACA,iC;AACA,yC;AACA,0B;AACA,yB;AACA,E;;;AAGA,G;AACA,W;AACA,G;;AAEA,mC;AACA,wC;AACA,sD;AACA,gC;;AAEA,uE;AACA,sE;AACA,kE;AACA,kD;AACA,8C;AACA,sC;AACA,E;;AAEA,yD;AACA,kD;AACA,qD;AACA,qB;AACA,yD;AACA,mE;;AAEA,oE;AACA,0B;AACA,mC;AACA,E;;AAEA,gC;AACA,6C;AACA,iD;AACA,wD;;AAEA,oE;AACA,0B;AACA,kC;AACA,E;;AAEA,sE;AACA,6B;AACA,E;AACA,4D;AACA,qD;AACA,E;;AAEA,uC;AACA,4D;AACA,E;;AAEA,+B;AACA,iD;AACA,E;;AAEA,kD;AACA,wE;AACA,yE;AACA,wB;AACA,E;;AAEA,G;AACA,c;AACA,G;;AAEA,uB;AACA,iE;AACA,iE;AACA,mC;AACA,iC;AACA,c;AACA,mE;AACA,kE;AACA,gC;AACA,oD;AACA,iD;AACA,gB;AACA,6D;AACA,8B;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,sE;AACA,c;AACA,iC;AACA,uC;AACA,yB;AACA,W;;AAEA,6C;;AAEA,gF;AACA,sD;AACA,4B;AACA,+D;AACA,gB;AACA,gC;AACA,S;AACA,Y;AACA,sB;AACA,K;AACA,G;AACA,+C;AACA,E;;AAEA,wC","sourcesContent":["Accounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// how long (in days) until a login token expires\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\n// Clients don't try to auto-login with a token that is going to expire within\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\n// Tries to avoid abrupt disconnects from expiring tokens.\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\n// how often (in milliseconds) we check for expired tokens\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\n// called\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n// - restrictCreationByEmailDomain {Function or String}\n//     Require created users to have an email matching the function or\n//     having the string as domain.\n// - loginExpirationInDays {Number}\n//     Number of days since login until a user is logged out (login token\n//     expires).\n//\nAccounts.config = function(options) {\n  // We don't want users to accidentally only call Accounts.config on the\n  // client, where some of the options will have partial effects (eg removing\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\n  // is set, or redirecting Google login to a specific-domain page) without\n  // having their full effects.\n  if (Meteor.isServer) {\n    __meteor_runtime_config__.accountsConfigCalled = true;\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\n    // message, but there's no trivial way to do this.\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\n                  \"server; some configuration options may not take effect.\");\n  }\n\n  // We need to validate the oauthSecretKey option at the time\n  // Accounts.config is called. We also deliberately don't store the\n  // oauthSecretKey in Accounts._options.\n  if (_.has(options, \"oauthSecretKey\")) {\n    if (Meteor.isClient)\n      throw new Error(\"The oauthSecretKey option may only be specified on the server\");\n    if (! Package[\"oauth-encryption\"])\n      throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\n    Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\n    options = _.omit(options, \"oauthSecretKey\");\n  }\n\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n\n  // If the user set loginExpirationInDays to null, then we need to clear the\n  // timer that periodically expires tokens.\n  if (Meteor.isServer)\n    maybeStopExpireTokensInterval();\n};\n\nif (Meteor.isClient) {\n  // The connection used by the Accounts system. This is the connection\n  // that will get logged in by Meteor.login(), and this is the\n  // connection whose login state will be reflected by Meteor.userId().\n  //\n  // It would be much preferable for this to be in accounts_client.js,\n  // but it has to be here because it's needed to create the\n  // Meteor.users collection.\n  Accounts.connection = Meteor.connection;\n\n  if (typeof __meteor_runtime_config__ !== \"undefined\" &&\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\n    // Temporary, internal hook to allow the server to point the client\n    // to a different authentication server. This is for a very\n    // particular use case that comes up when implementing a oauth\n    // server. Unsupported and may go away at any point in time.\n    //\n    // We will eventually provide a general way to use account-base\n    // against any DDP connection, not just one special one.\n    Accounts.connection = DDP.connect(\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL)\n  }\n}\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n//\nMeteor.users = new Meteor.Collection(\"users\", {\n  _preventAutopublish: true,\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nMeteor.startup(function () {\n  var ServiceConfiguration =\n    Package['service-configuration'].ServiceConfiguration;\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\n});\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\ngetTokenLifetimeMs = function () {\n  return (Accounts._options.loginExpirationInDays ||\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n};\n\nAccounts._tokenExpiration = function (when) {\n  // We pass when through the Date constructor for backwards compatibility;\n  // `when` used to be a number.\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\n};\n\nAccounts._tokenExpiresSoon = function (when) {\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\n  if (minLifetimeMs > minLifetimeCapMs)\n    minLifetimeMs = minLifetimeCapMs;\n  return new Date() > (new Date(when) - minLifetimeMs);\n};\n","autoLoginEnabled = true;\n\n// reads a reset password token from the url's hash fragment, if it's\n// there. if so prevent automatically logging in since it could be\n// confusing to be logged in as user A while resetting password for\n// user B\n//\n// reset password urls use hash fragments instead of url paths/query\n// strings so that the reset password token is not sent over the wire\n// on the http request\nvar match;\nmatch = window.location.hash.match(/^\\#\\/reset-password\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._resetPasswordToken = match[1];\n  window.location.hash = '';\n}\n\n// reads a verify email token from the url's hash fragment, if\n// it's there.  also don't automatically log the user is, as for\n// reset password links.\n//\n// XXX we don't need to use hash fragments in this case, and having\n// the token appear in the url's path would allow us to use a custom\n// middleware instead of verifying the email on pageload, which\n// would be faster but less DDP-ish (and more specifically, any\n// non-web DDP app, such as an iOS client, would do something more\n// in line with the hash fragment approach)\nmatch = window.location.hash.match(/^\\#\\/verify-email\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._verifyEmailToken = match[1];\n  window.location.hash = '';\n}\n\n// reads an account enrollment token from the url's hash fragment, if\n// it's there.  also don't automatically log the user is, as for\n// reset password links.\nmatch = window.location.hash.match(/^\\#\\/enroll-account\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._enrollAccountToken = match[1];\n  window.location.hash = '';\n}\n","///\n/// CURRENT USER\n///\n\n// This is reactive.\nMeteor.userId = function () {\n  return Accounts.connection.userId();\n};\n\nvar loggingIn = false;\nvar loggingInDeps = new Deps.Dependency;\n// This is mostly just called within this file, but Meteor.loginWithPassword\n// also uses it to make loggingIn() be true during the beginPasswordExchange\n// method call too.\nAccounts._setLoggingIn = function (x) {\n  if (loggingIn !== x) {\n    loggingIn = x;\n    loggingInDeps.changed();\n  }\n};\nMeteor.loggingIn = function () {\n  loggingInDeps.depend();\n  return loggingIn;\n};\n\n// This calls userId, which is reactive.\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAccounts.callLoginMethod = function (options) {\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [],\n    _suppressLoggingIn: false\n  }, options);\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n  // make sure we only call the user's callback once.\n  var onceUserCallback = _.once(options.userCallback);\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      Accounts.connection.onReconnect = null;\n    } else {\n      Accounts.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = Accounts._tokenExpiration(new Date());\n        if (Accounts._tokenExpiresSoon(result.tokenExpires)) {\n          makeClientLoggedOut();\n        } else {\n          Accounts.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              onceUserCallback(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    Accounts._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      onceUserCallback(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      onceUserCallback(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    onceUserCallback();\n  };\n\n  if (!options._suppressLoggingIn)\n    Accounts._setLoggingIn(true);\n  Accounts.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nmakeClientLoggedOut = function() {\n  unstoreLoginToken();\n  Accounts.connection.setUserId(null);\n  Accounts.connection.onReconnect = null;\n};\n\nmakeClientLoggedIn = function(userId, token, tokenExpires) {\n  storeLoginToken(userId, token, tokenExpires);\n  Accounts.connection.setUserId(userId);\n};\n\nMeteor.logout = function (callback) {\n  Accounts.connection.apply('logout', [], {wait: true}, function(error, result) {\n    if (error) {\n      callback && callback(error);\n    } else {\n      makeClientLoggedOut();\n      callback && callback();\n    }\n  });\n};\n\nMeteor.logoutOtherClients = function (callback) {\n  // We need to make two method calls: one to replace our current token,\n  // and another to remove all tokens except the current one. We want to\n  // call these two methods one after the other, without any other\n  // methods running between them. For example, we don't want `logout`\n  // to be called in between our two method calls (otherwise the second\n  // method call would return an error). Another example: we don't want\n  // logout to be called before the callback for `getNewToken`;\n  // otherwise we would momentarily log the user out and then write a\n  // new token to localStorage.\n  //\n  // To accomplish this, we make both calls as wait methods, and queue\n  // them one after the other, without spinning off the event loop in\n  // between. Even though we queue `removeOtherTokens` before\n  // `getNewToken`, we won't actually send the `removeOtherTokens` call\n  // until the `getNewToken` callback has finished running, because they\n  // are both wait methods.\n  Accounts.connection.apply(\n    'getNewToken',\n    [],\n    { wait: true },\n    function (err, result) {\n      if (! err) {\n        storeLoginToken(Meteor.userId(), result.token, result.tokenExpires);\n      }\n    }\n  );\n  Accounts.connection.apply(\n    'removeOtherTokens',\n    [],\n    { wait: true },\n    function (err) {\n      callback && callback(err);\n    }\n  );\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\nvar loginServicesHandle =\n  Accounts.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAccounts.loginServicesConfigured = function () {\n  return loginServicesHandle.ready();\n};\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a UI, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.ui) {\n  Package.ui.UI.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n  Package.ui.UI.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n","// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\nvar lastLoginTokenWhenPolled;\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  Accounts.callLoginMethod({\n    methodArguments: [{resume: token}],\n    userCallback: callback});\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAccounts._enableAutoLogin = function () {\n  autoLoginEnabled = true;\n  pollStoredLoginToken();\n};\n\n\n///\n/// STORING\n///\n\n// Key names to use in localStorage\nvar loginTokenKey = \"Meteor.loginToken\";\nvar loginTokenExpiresKey = \"Meteor.loginTokenExpires\";\nvar userIdKey = \"Meteor.userId\";\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAccounts._isolateLoginTokenForTest = function () {\n  loginTokenKey = loginTokenKey + Random.id();\n  userIdKey = userIdKey + Random.id();\n};\n\nstoreLoginToken = function(userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(userIdKey, userId);\n  Meteor._localStorage.setItem(loginTokenKey, token);\n  if (! tokenExpires)\n    tokenExpires = Accounts._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(loginTokenExpiresKey, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = token;\n};\n\nunstoreLoginToken = function() {\n  Meteor._localStorage.removeItem(userIdKey);\n  Meteor._localStorage.removeItem(loginTokenKey);\n  Meteor._localStorage.removeItem(loginTokenExpiresKey);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nstoredLoginToken = Accounts._storedLoginToken = function() {\n  return Meteor._localStorage.getItem(loginTokenKey);\n};\n\nstoredLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(loginTokenExpiresKey);\n};\n\nvar storedUserId = function() {\n  return Meteor._localStorage.getItem(userIdKey);\n};\n\nvar unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = Meteor._localStorage.getItem(loginTokenExpiresKey);\n  if (tokenExpires && Accounts._tokenExpiresSoon(new Date(tokenExpires)))\n    unstoreLoginToken();\n};\n\n///\n/// AUTO-LOGIN\n///\n\nif (autoLoginEnabled) {\n  // Immediately try to log in via local storage, so that any DDP\n  // messages are sent after we have established our user account\n  unstoreLoginTokenIfExpiresSoon();\n  var token = storedLoginToken();\n  if (token) {\n    // On startup, optimistically present us as logged in while the\n    // request is in flight. This reduces page flicker on startup.\n    var userId = storedUserId();\n    userId && Accounts.connection.setUserId(userId);\n    Meteor.loginWithToken(token, function (err) {\n      if (err) {\n        Meteor._debug(\"Error logging in with token: \" + err);\n        makeClientLoggedOut();\n      }\n    });\n  }\n}\n\n// Poll local storage every 3 seconds to login if someone logged in in\n// another tab\nlastLoginTokenWhenPolled = token;\nvar pollStoredLoginToken = function() {\n  if (! autoLoginEnabled)\n    return;\n\n  var currentLoginToken = storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      Meteor.loginWithToken(currentLoginToken, function (err) {\n        if (err)\n          makeClientLoggedOut();\n      });\n    } else {\n      Meteor.logout();\n    }\n  }\n  lastLoginTokenWhenPolled = currentLoginToken;\n};\n\nsetInterval(pollStoredLoginToken, 3000);\n"]}