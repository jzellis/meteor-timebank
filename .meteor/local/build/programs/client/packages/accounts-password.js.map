)]}'
{"version":3,"file":"/packages/accounts-password.js","sources":["accounts-password/password_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qC;AACA,E;AACA,wD;AACA,6B;AACA,uB;AACA,sE;AACA,uB;AACA,2B;AACA,8C;AACA,oE;AACA,mC;AACA,qC;AACA,sC;AACA,Q;AACA,mC;;AAEA,4B;AACA,uB;AACA,qB;AACA,sC;AACA,O;AACA,4C;AACA,yC;AACA,mD;AACA,mE;AACA,wD;;AAEA,kC;AACA,mE;AACA,qE;AACA,oE;AACA,mE;AACA,wE;AACA,qE;AACA,mE;AACA,0D;AACA,wB;AACA,8B;AACA,iC;AACA,qC;AACA,qB;AACA,O;AACA,uB;AACA,wB;AACA,c;AACA,mB;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,wC;AACA,U;AACA,6B;AACA,wB;AACA,I;AACA,E;;AAEA,0B;AACA,oE;AACA,uD;AACA,sE;AACA,wC;AACA,yD;AACA,kD;AACA,mD;AACA,c;AACA,O;AACA,wD;AACA,gB;AACA,+C;AACA,kC;AACA,qE;AACA,4C;AACA,U;AACA,8B;AACA,yB;AACA,mC;AACA,wE;AACA,yD;AACA,S;AACA,4B;AACA,O;AACA,G;AACA,E;;;AAGA,mC;AACA,oD;AACA,2D;;AAEA,wB;AACA,iD;;AAEA,+C;AACA,oD;;AAEA,4B;AACA,6B;AACA,+B;AACA,0B;AACA,K;AACA,E;;;;AAIA,sC;AACA,E;AACA,sE;AACA,qE;AACA,qE;AACA,8B;AACA,8C;AACA,yE;AACA,uB;AACA,6E;AACA,W;AACA,G;;AAEA,4B;AACA,qB;AACA,gF;AACA,8B;AACA,6B;AACA,2C;AACA,qD;AACA,oC;AACA,uE;AACA,yC;AACA,0B;AACA,gC;AACA,kD;AACA,0C;AACA,6B;AACA,sB;AACA,4B;AACA,oB;AACA,iE;AACA,yD;AACA,0E;AACA,a;AACA,a;AACA,gB;AACA,yE;AACA,+B;AACA,kE;AACA,S;AACA,c;AACA,+B;AACA,O;AACA,K;AACA,I;AACA,E;;AAEA,iE;AACA,iB;AACA,E;AACA,0B;AACA,qB;AACA,yD;AACA,uD;AACA,qB;AACA,+C;AACA,gE;AACA,E;;AAEA,2D;AACA,+D;AACA,E;AACA,wB;AACA,8B;AACA,yD;AACA,iE;AACA,a;AACA,0C;AACA,mB;AACA,gD;;AAEA,4B;AACA,gC;AACA,wD;AACA,6B;AACA,E;;AAEA,8D;AACA,4C;AACA,E;AACA,wB;AACA,yD;AACA,kD;AACA,a;AACA,0C;;AAEA,4B;AACA,8B;AACA,6B;AACA,6B;AACA,E","sourcesContent":["// Attempt to log in with a password.\n//\n// @param selector {String|Object} One of the following:\n//   - {username: (username)}\n//   - {email: (email)}\n//   - a string which may be a username or email, depending on whether\n//     it contains \"@\".\n// @param password {String}\n// @param callback {Function(error|undefined)}\nMeteor.loginWithPassword = function (selector, password, callback) {\n  if (typeof selector === 'string')\n    if (selector.indexOf('@') === -1)\n      selector = {username: selector};\n    else\n      selector = {email: selector};\n\n  Accounts.callLoginMethod({\n    methodArguments: [{\n      user: selector,\n      password: hashPassword(password)\n    }],\n    userCallback: function (error, result) {\n      if (error && error.error === 400 &&\n          error.reason === 'old password format') {\n        // The \"reason\" string should match the error thrown in the\n        // password login handler in password_server.js.\n\n        // XXX COMPAT WITH 0.8.1.3\n        // If this user's last login was with a previous version of\n        // Meteor that used SRP, then the server throws this error to\n        // indicate that we should try again. The error includes the\n        // user's SRP identity. We provide a value derived from the\n        // identity and the password to prove to the server that we know\n        // the password without requiring a full SRP flow, as well as\n        // SHA256(password), which the server bcrypts and stores in\n        // place of the old SRP information for this user.\n        srpUpgradePath({\n          upgradeError: error,\n          userSelector: selector,\n          plaintextPassword: password\n        }, callback);\n      }\n      else if (error) {\n        callback(error);\n      } else {\n        callback();\n      }\n    }\n  });\n};\n\nvar hashPassword = function (password) {\n  return {\n    digest: SHA256(password),\n    algorithm: \"sha-256\"\n  };\n};\n\n// XXX COMPAT WITH 0.8.1.3\n// The server requested an upgrade from the old SRP password format,\n// so supply the needed SRP identity to login. Options:\n//   - upgradeError: the error object that the server returned to tell\n//     us to upgrade from SRP to bcrypt.\n//   - userSelector: selector to retrieve the user object\n//   - plaintextPassword: the password as a string\nvar srpUpgradePath = function (options, callback) {\n  var details;\n  try {\n    details = EJSON.parse(options.upgradeError.details);\n  } catch (e) {}\n  if (!(details && details.format === 'srp')) {\n    callback(new Meteor.Error(400,\n                              \"Password is old. Please reset your \" +\n                              \"password.\"));\n  } else {\n    Accounts.callLoginMethod({\n      methodArguments: [{\n        user: options.userSelector,\n        srp: SHA256(details.identity + \":\" + options.plaintextPassword),\n        password: hashPassword(options.plaintextPassword)\n      }],\n      userCallback: callback\n    });\n  }\n};\n\n\n// Attempt to log in as a new user.\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options); // we'll be modifying options\n\n  if (!options.password)\n    throw new Error(\"Must set options.password\");\n\n  // Replace password with the hashed password.\n  options.password = hashPassword(options.password);\n\n  Accounts.callLoginMethod({\n    methodName: 'createUser',\n    methodArguments: [options],\n    userCallback: callback\n  });\n};\n\n\n\n// Change password. Must be logged in.\n//\n// @param oldPassword {String|null} By default servers no longer allow\n//   changing password without the old password, but they could so we\n//   support passing no password to the server and letting it decide.\n// @param newPassword {String}\n// @param callback {Function(error|undefined)}\nAccounts.changePassword = function (oldPassword, newPassword, callback) {\n  if (!Meteor.user()) {\n    callback && callback(new Error(\"Must be logged in to change password.\"));\n    return;\n  }\n\n  Accounts.connection.apply(\n    'changePassword',\n    [oldPassword ? hashPassword(oldPassword) : null, hashPassword(newPassword)],\n    function (error, result) {\n      if (error || !result) {\n        if (error && error.error === 400 &&\n            error.reason === 'old password format') {\n          // XXX COMPAT WITH 0.8.1.3\n          // The server is telling us to upgrade from SRP to bcrypt, as\n          // in Meteor.loginWithPassword.\n          srpUpgradePath({\n            upgradeError: error,\n            userSelector: { id: Meteor.userId() },\n            plaintextPassword: oldPassword\n          }, function (err) {\n            if (err) {\n              callback(err);\n            } else {\n              // Now that we've successfully migrated from srp to\n              // bcrypt, try changing the password again.\n              Accounts.changePassword(oldPassword, newPassword, callback);\n            }\n          });\n        } else {\n          // A normal error, not an error telling us to upgrade to bcrypt\n          callback && callback(\n            error || new Error(\"No result from changePassword.\"));\n        }\n      } else {\n        callback && callback();\n      }\n    }\n  );\n};\n\n// Sends an email to a user with a link that can be used to reset\n// their password\n//\n// @param options {Object}\n//   - email: (email)\n// @param callback (optional) {Function(error|undefined)}\nAccounts.forgotPassword = function(options, callback) {\n  if (!options.email)\n    throw new Error(\"Must pass options.email\");\n  Accounts.connection.call(\"forgotPassword\", options, callback);\n};\n\n// Resets a password based on a token originally created by\n// Accounts.forgotPassword, and then logs in the matching user.\n//\n// @param token {String}\n// @param newPassword {String}\n// @param callback (optional) {Function(error|undefined)}\nAccounts.resetPassword = function(token, newPassword, callback) {\n  if (!token)\n    throw new Error(\"Need to pass token\");\n  if (!newPassword)\n    throw new Error(\"Need to pass newPassword\");\n\n  Accounts.callLoginMethod({\n    methodName: 'resetPassword',\n    methodArguments: [token, hashPassword(newPassword)],\n    userCallback: callback});\n};\n\n// Verifies a user's email address based on a token originally\n// created by Accounts.sendVerificationEmail\n//\n// @param token {String}\n// @param callback (optional) {Function(error|undefined)}\nAccounts.verifyEmail = function(token, callback) {\n  if (!token)\n    throw new Error(\"Need to pass token\");\n\n  Accounts.callLoginMethod({\n    methodName: 'verifyEmail',\n    methodArguments: [token],\n    userCallback: callback});\n};\n"]}