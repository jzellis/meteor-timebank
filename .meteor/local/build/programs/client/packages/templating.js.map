)]}'
{"version":3,"file":"/packages/templating.js","sources":["templating/deftemplate.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,4B;;AAEA,+E;AACA,8E;AACA,kC;AACA,mC;AACA,kD;AACA,iC;;AAEA,4C;AACA,kC;AACA,8D;;AAEA,8C;AACA,8D;AACA,kC;AACA,2B;AACA,iC;AACA,8D;AACA,M;AACA,sB;AACA,0E;AACA,sD;;AAEA,gE;AACA,uD;AACA,0C;AACA,2C;;AAEA,sB;AACA,U;AACA,uB;AACA,iC;AACA,0F;AACA,qE;AACA,oD;AACA,a;AACA,Q;AACA,mB;AACA,gC;AACA,8C;AACA,O;AACA,M;AACA,I;;AAEA,yC;AACA,iC;AACA,sB;AACA,wC;AACA,gC;AACA,S;AACA,M;AACA,kC;AACA,sB;AACA,mE;AACA,gC;AACA,S;AACA,K;AACA,K;AACA,E;;AAEA,iD;AACA,oD;AACA,8B;;AAEA,mD;AACA,uD;AACA,yC;AACA,uB;AACA,iC;AACA,gC;AACA,iD;AACA,uC;AACA,Q;AACA,oC;AACA,gC;AACA,iD;AACA,0C;AACA,O;AACA,O;AACA,wB;AACA,uE;AACA,qE;AACA,kB;AACA,E;;AAEA,2C;AACA,oB;AACA,0E;AACA,mB;AACA,sD;AACA,+B;AACA,gB;AACA,oE;AACA,+C;AACA,0C;AACA,kC;AACA,O;AACA,I;AACA,oC;AACA,kB;AACA,wE;;AAEA,+B;AACA,+C;AACA,kC;AACA,S;AACA,Q;AACA,sC;AACA,I;AACA,iC;AACA,iB;AACA,sE;AACA,2B;AACA,gC;AACA,G;AACA,E;;AAEA,iD;AACA,mB;;AAEA,4B;AACA,kE;AACA,gE;;AAEA,qD;;AAEA,iC;AACA,4C;AACA,yC;;AAEA,gE;AACA,uC;AACA,0C;AACA,8B;AACA,uD;AACA,+B;AACA,sD;AACA,U;AACA,+B;AACA,uD;AACA,+B;AACA,wD;AACA,U;AACA,gC;AACA,iE;AACA,2B;AACA,+D;AACA,+C;AACA,S;AACA,8B;AACA,8C;AACA,oE;AACA,qC;AACA,iC;AACA,mE;AACA,yC;AACA,sB;AACA,a;AACA,W;;AAEA,uE;AACA,qE;AACA,uE;AACA,mD;AACA,+B;AACA,wD;AACA,iD;AACA,0E;AACA,sC;AACA,a;AACA,mE;AACA,iD;AACA,gD;AACA,uE;AACA,gB;AACA,e;AACA,a;AACA,6B;AACA,U;;AAEA,yD;AACA,oB;AACA,oD;AACA,8C;AACA,iE;AACA,mE;AACA,4C;AACA,wB;AACA,gE;AACA,oB;AACA,S;AACA,8C;AACA,kB;AACA,O;;AAEA,gB;AACA,I;;AAEA,gE;AACA,8D;AACA,gE;AACA,mC;AACA,wC;;;AAGA,a;AACA,uB;AACA,qE;AACA,+D;;AAEA,6B;AACA,oC;AACA,4B;;AAEA,uC;AACA,G;;AAEA,4C;AACA,iB;AACA,E","sourcesContent":["Template = {};\n\nvar registeredPartials = {};\n\n// If minimongo is available (it's a weak dependency) use its ID stringifier to\n// label branches (so that, eg, ObjectId and strings don't overlap). Otherwise\n// just use the identity function.\nvar idStringify = Package.minimongo\n  ? Package.minimongo.LocalCollection._idStringify\n  : function (id) { return id; };\n\n// XXX Handlebars hooking is janky and gross\nvar hookHandlebars = function () {\n  hookHandlebars = function(){}; // install the hook only once\n\n  var orig = Handlebars._default_helpers.each;\n  Handlebars._default_helpers.each = function (arg, options) {\n    var isArgValid = function () {\n      return !arg // falsey\n        || (arg instanceof Array)\n        || (arg instanceof Object && 'observeChanges' in arg);\n    };\n    if (!isArgValid())\n      throw new Error(\"{{#each}} only accepts arrays, cursors, or falsey \"\n                      + \"values. You passed: \" + arg);\n\n    // if arg isn't an observable (like LocalCollection.Cursor),\n    // don't use this reactive implementation of #each.\n    if (!(arg && 'observeChanges' in arg))\n      return orig.call(this, arg, options);\n\n    return Spark.list(\n      arg,\n      function (item) {\n        return Spark.labelBranch(\n          (item && item._id && idStringify(item._id)) || Spark.UNIQUE_LABEL, function () {\n            var html = Spark.isolate(_.bind(options.fn, null, item));\n            return Spark.setDataContext(item, html);\n          });\n      },\n      function () {\n        return options.inverse ?\n          Spark.isolate(options.inverse) : '';\n      }\n    );\n  };\n\n  _.extend(Handlebars._default_helpers, {\n    isolate: function (options) {\n      var data = this;\n      return Spark.isolate(function () {\n        return options.fn(data);\n      });\n    },\n    constant: function (options) {\n      var data = this;\n      return Spark.createLandmark({ constant: true }, function () {\n        return options.fn(data);\n      });\n    }\n  });\n};\n\n// map from landmark id, to the 'this' object for\n// created/rendered/destroyed callbacks on templates\nvar templateInstanceData = {};\n\nvar templateObjFromLandmark = function (landmark) {\n  var template = templateInstanceData[landmark.id] || (\n    templateInstanceData[landmark.id] = {\n      // set these once\n      find: function (selector) {\n        if (! landmark.hasDom())\n          throw new Error(\"Template not in DOM\");\n        return landmark.find(selector);\n      },\n      findAll: function (selector) {\n        if (! landmark.hasDom())\n          throw new Error(\"Template not in DOM\");\n        return landmark.findAll(selector);\n      }\n    });\n  // set these each time\n  template.firstNode = landmark.hasDom() ? landmark.firstNode() : null;\n  template.lastNode = landmark.hasDom() ? landmark.lastNode() : null;\n  return template;\n};\n\n// XXX forms hooks into this to add \"bind\"?\nvar templateBase = {\n  // methods store data here (event map, etc.).  initialized per template.\n  _tmpl_data: null,\n  // these functions must be generic (i.e. use `this`)\n  events: function (eventMap) {\n    var events =\n          (this._tmpl_data.events = (this._tmpl_data.events || {}));\n    _.each(eventMap, function(callback, spec) {\n      events[spec] = (events[spec] || []);\n      events[spec].push(callback);\n    });\n  },\n  preserve: function (preserveMap) {\n    var preserve =\n          (this._tmpl_data.preserve = (this._tmpl_data.preserve || {}));\n\n    if (_.isArray(preserveMap))\n      _.each(preserveMap, function (selector) {\n        preserve[selector] = true;\n      });\n    else\n      _.extend(preserve, preserveMap);\n  },\n  helpers: function (helperMap) {\n    var helpers =\n          (this._tmpl_data.helpers = (this._tmpl_data.helpers || {}));\n    for(var h in helperMap)\n      helpers[h] = helperMap[h];\n  }\n};\n\nTemplate.__define__ = function (name, raw_func) {\n  hookHandlebars();\n\n  if (name === '__define__')\n    throw new Error(\"Sorry, '__define__' is a special name and \" +\n                    \"cannot be used as the name of a template\");\n\n  // Define the function assigned to Template.<name>.\n\n  var partial = function (data) {\n    var tmpl = name && Template[name] || {};\n    var tmplData = tmpl._tmpl_data || {};\n\n    var html = Spark.labelBranch(\"Template.\"+name, function () {\n      var html = Spark.createLandmark({\n        preserve: tmplData.preserve || {},\n        created: function () {\n          var template = templateObjFromLandmark(this);\n          template.data = data;\n          tmpl.created && tmpl.created.call(template);\n        },\n        rendered: function () {\n          var template = templateObjFromLandmark(this);\n          template.data = data;\n          tmpl.rendered && tmpl.rendered.call(template);\n        },\n        destroyed: function () {\n          // template.data is already set from previous callbacks\n          tmpl.destroyed &&\n            tmpl.destroyed.call(templateObjFromLandmark(this));\n          delete templateInstanceData[this.id];\n        }\n      }, function (landmark) {\n        var html = Spark.isolate(function () {\n          // XXX Forms needs to run a hook before and after raw_func\n          // (and receive 'landmark')\n          return raw_func(data, {\n            helpers: _.extend({}, partial, tmplData.helpers || {}),\n            partials: registeredPartials,\n            name: name\n          });\n        });\n\n        // take an event map with `function (event, template)` handlers\n        // and produce one with `function (event, landmark)` handlers\n        // for Spark, by inserting logic to create the template object.\n        var wrapEventMap = function (oldEventMap) {\n          var newEventMap = {};\n          _.each(oldEventMap, function (handlers, key) {\n            if ('function' === typeof handlers) {\n              //Template.foo.events = ... way will give a fn, not an array\n              handlers = [ handlers ];\n            }\n            newEventMap[key] = _.map(handlers, function (handler) {\n              return function (event, landmark) {\n                return handler.call(this, event,\n                                    templateObjFromLandmark(landmark));\n              };\n            });\n          });\n          return newEventMap;\n        };\n\n        // support old Template.foo.events = {...} format\n        var events =\n              (tmpl.events !== templateBase.events ?\n               tmpl.events : tmplData.events);\n        // events need to be inside the landmark, not outside, so\n        // that when an event fires, you can retrieve the enclosing\n        // landmark to get the template data\n        if (tmpl.events)\n          html = Spark.attachEvents(wrapEventMap(events), html);\n        return html;\n      });\n      html = Spark.setDataContext(data, html);\n      return html;\n    });\n\n    return html;\n  };\n\n  // XXX hack.. copy all of Handlebars' built in helpers over to\n  // the partial. it would be better to hook helperMissing (or\n  // something like that?) so that Template.foo is searched only\n  // if it's not a built-in helper.\n  _.extend(partial, Handlebars.helpers);\n\n\n  if (name) {\n    if (Template[name])\n      throw new Error(\"There are multiple templates named '\" + name +\n                      \"'. Each template needs a unique name.\");\n\n    Template[name] = partial;\n    _.extend(partial, templateBase);\n    partial._tmpl_data = {};\n\n    registeredPartials[name] = partial;\n  }\n\n  // useful for unnamed templates, like body\n  return partial;\n};\n"]}