)]}'
{"version":3,"file":"/packages/handlebars.js","sources":["handlebars/evaluate-handlebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gB;;AAEA,qE;AACA,yC;;AAEA,wD;AACA,wC;;AAEA,8C;AACA,mC;AACA,mD;AACA,I;AACA,E;;AAEA,+E;AACA,8E;AACA,kC;AACA,mC;AACA,kD;AACA,iC;;AAEA,sB;AACA,yD;AACA,kB;AACA,E;AACA,uB;AACA,gC;AACA,E;AACA,mC;;AAEA,mE;AACA,2D;AACA,iE;AACA,oE;AACA,yC;AACA,+B;AACA,oC;AACA,yD;AACA,mC;AACA,Q;AACA,8B;AACA,I;AACA,oC;AACA,0B;AACA,gC;AACA,yC;AACA,2C;AACA,2D;AACA,2D;AACA,0C;AACA,qD;AACA,+B;AACA,W;AACA,kB;AACA,Q;AACA,+B;AACA,e;AACA,qB;AACA,6C;AACA,W;AACA,I;AACA,kC;AACA,yD;AACA,mC;AACA,Q;AACA,8B;AACA,I;AACA,sC;AACA,yD;AACA,8B;AACA,Q;AACA,mC;AACA,G;AACA,E;;AAEA,mD;AACA,0C;AACA,gE;AACA,2C;AACA,E;;AAEA,mC;AACA,kC;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,oF;AACA,0D;;AAEA,qD;AACA,0B;AACA,0D;AACA,2C;AACA,wC;;AAEA,sE;AACA,2D;AACA,oE;AACA,mE;AACA,mE;AACA,kE;AACA,qE;AACA,yB;;AAEA,yC;AACA,gC;AACA,gB;;AAEA,uC;AACA,qC;AACA,wB;AACA,kD;AACA,U;AACA,6B;AACA,K;;AAEA,wB;AACA,6C;AACA,wB;;AAEA,gC;AACA,uB;AACA,2D;AACA,8D;AACA,sB;AACA,uC;AACA,6B;AACA,K;;AAEA,iE;AACA,4D;AACA,iE;AACA,gE;AACA,oD;AACA,8B;;AAEA,a;AACA,4E;AACA,uC;AACA,4B;AACA,Y;AACA,uC;AACA,4D;AACA,8B;AACA,iE;AACA,qE;AACA,iE;AACA,yE;AACA,sE;AACA,wC;AACA,mE;AACA,mE;AACA,4E;AACA,O;AACA,uD;AACA,+C;AACA,K;;AAEA,qC;AACA,yC;AACA,uD;AACA,sC;AACA,Q;AACA,gE;AACA,0B;AACA,4B;AACA,6B;AACA,gC;AACA,Q;AACA,uD;AACA,2D;AACA,wD;AACA,uD;AACA,gC;AACA,uC;AACA,mC;AACA,wB;AACA,O;AACA,gD;AACA,sD;AACA,0D;AACA,kB;AACA,c;AACA,O;;AAEA,yB;AACA,K;;AAEA,2D;AACA,uD;AACA,wD;AACA,+C;AACA,mC;AACA,oC;;AAEA,gB;AACA,I;;AAEA,iD;AACA,wD;AACA,0D;AACA,+C;AACA,0D;AACA,wB;AACA,6B;;AAEA,yD;AACA,qC;AACA,yC;AACA,kB;AACA,gE;AACA,6D;AACA,wB;AACA,0C;AACA,0C;AACA,qE;AACA,S;AACA,K;;AAEA,0C;AACA,iC;AACA,sC;AACA,0C;AACA,oE;AACA,gB;AACA,yB;AACA,+C;AACA,M;;AAEA,0C;AACA,sC;AACA,+C;;AAEA,yC;AACA,uB;;AAEA,wC;AACA,sD;AACA,2B;AACA,6B;AACA,uC;AACA,0C;AACA,8D;AACA,qD;AACA,mC;AACA,yD;AACA,sB;AACA,Y;AACA,wB;AACA,K;;AAEA,gC;AACA,I;;AAEA,oD;AACA,iB;;AAEA,iC;AACA,0C;AACA,kD;AACA,oC;AACA,qC;AACA,0B;AACA,M;;AAEA,0E;AACA,0E;AACA,6B;AACA,kD;AACA,6B;AACA,8D;AACA,qE;AACA,uB;AACA,iD;AACA,kD;AACA,0B;AACA,Y;AACA,sD;AACA,Q;AACA,M;;AAEA,+C;AACA,e;AACA,4B;AACA,6D;AACA,yD;AACA,mC;AACA,6C;AACA,4B;AACA,6C;AACA,M;;AAEA,iB;AACA,sD;AACA,+D;AACA,iE;AACA,4D;AACA,+B;AACA,yD;AACA,M;AACA,uC;AACA,mE;AACA,sE;AACA,iE;AACA,mE;AACA,8D;AACA,M;;AAEA,wC;AACA,uB;AACA,mC;AACA,sB;AACA,8B;AACA,4B;AACA,6C;AACA,oD;AACA,Y;AACA,8B;AACA,8B;AACA,6C;AACA,uD;AACA,Y;AACA,gC;AACA,4B;AACA,+B;AACA,oC;AACA,2B;AACA,wE;AACA,yB;AACA,yB;AACA,wC;AACA,2B;AACA,8E;AACA,yB;AACA,+C;AACA,8D;AACA,W;AACA,uB;AACA,kC;AACA,wB;AACA,iC;AACA,uC;AACA,6E;AACA,oE;AACA,2B;AACA,oD;AACA,6D;AACA,W;AACA,uB;AACA,Y;AACA,mD;AACA,O;;AAEA,wB;AACA,I;;AAEA,qE;AACA,uC;AACA,yE;AACA,mE;AACA,yC;;AAEA,8D;AACA,E;;AAEA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["Handlebars = {};\n\n// XXX we probably forgot to implement the #foo case where foo is not\n// a helper (and similarly the ^foo case)\n\n// XXX there is a ton of stuff that needs testing! like,\n// everything. including the '..' stuff.\n\nHandlebars.json_ast_to_func = function (ast) {\n  return function (data, options) {\n    return Handlebars.evaluate(ast, data, options);\n  };\n};\n\n// If minimongo is available (it's a weak dependency) use its ID stringifier to\n// label branches (so that, eg, ObjectId and strings don't overlap). Otherwise\n// just use the identity function.\nvar idStringify = Package.minimongo\n  ? Package.minimongo.LocalCollection._idStringify\n  : function (id) { return id; };\n\n// block helpers take:\n// (N args), options (hash args, plus 'fn' and 'inverse')\n// and return text\n//\n// normal helpers take:\n// (N args), options (hash args)\n//\n// partials take one argument, data\n\n// XXX handlebars' format for arguments is not the clearest, likely\n// for backwards compatibility to mustache. eg, options ===\n// options.fn. take the opportunity to clean this up. treat block\n// arguments (fn, inverse) as just another kind of argument, same as\n// what is passed in via named arguments.\nHandlebars._default_helpers = {\n  'with': function (data, options) {\n    if (!data || (data instanceof Array && !data.length))\n      return options.inverse(this);\n    else\n      return options.fn(data);\n  },\n  'each': function (data, options) {\n    var parentData = this;\n    if (data && data.length > 0)\n      return _.map(data, function(x, i) {\n        // infer a branch key from the data\n        var branch = ((x && x._id && idStringify(x._id)) ||\n                      (typeof x === 'string' ? x : null) ||\n                      Spark.UNIQUE_LABEL);\n        return Spark.labelBranch(branch, function() {\n          return options.fn(x);\n        });\n      }).join('');\n    else\n      return Spark.labelBranch(\n        'else',\n        function () {\n          return options.inverse(parentData);\n        });\n  },\n  'if': function (data, options) {\n    if (!data || (data instanceof Array && !data.length))\n      return options.inverse(this);\n    else\n      return options.fn(this);\n  },\n  'unless': function (data, options) {\n    if (!data || (data instanceof Array && !data.length))\n      return options.fn(this);\n    else\n      return options.inverse(this);\n  }\n};\n\nHandlebars.registerHelper = function (name, func) {\n  if (name in Handlebars._default_helpers)\n    throw new Error(\"There is already a helper '\" + name + \"'\");\n  Handlebars._default_helpers[name] = func;\n};\n\n// Utility to HTML-escape a string.\nHandlebars._escape = (function() {\n  var escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  var escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\n// be able to recognize default \"this\", which is different in different environments\nHandlebars._defaultThis = (function() { return this; })();\n\nHandlebars.evaluate = function (ast, data, options) {\n  options = options || {};\n  var helpers = _.extend({}, Handlebars._default_helpers);\n  _.extend(helpers, options.helpers || {});\n  var partials = options.partials || {};\n\n  // re 'stack' arguments: top of stack is the current data to use for\n  // the template. higher levels are the data referenced by\n  // identifiers with one or more '..' segments. we have to keep the\n  // stack pure-functional style, with a tree rather than an array,\n  // because we want to continue to allow block helpers provided by\n  // the user to capture their subtemplate rendering functions and\n  // call them later, after we've finished running (for eg findLive.)\n  // maybe revisit later.\n\n  var eval_value = function (stack, id) {\n    if (typeof(id) !== \"object\")\n      return id;\n\n    // follow '..' in {{../../foo.bar}}\n    for (var i = 0; i < id[0]; i++) {\n      if (!stack.parent)\n        throw new Error(\"Too many '..' segments\");\n      else\n        stack = stack.parent;\n    }\n\n    if (id.length === 1)\n      // no name: {{this}}, {{..}}, {{../..}}\n      return stack.data;\n\n    var scopedToContext = false;\n    if (id[1] === '') {\n      // an empty path segment is our AST's way of encoding\n      // the presence of 'this.' at the beginning of the path.\n      id = id.slice();\n      id.splice(1, 1); // remove the ''\n      scopedToContext = true;\n    }\n\n    // when calling functions (helpers/methods/getters), dataThis\n    // tracks what to use for `this`.  For helpers, it's the\n    // current data context.  For getters and methods on the data\n    // context object, and on the return value of a helper, it's\n    // the object where we got the getter or method.\n    var dataThis = stack.data;\n\n    var data;\n    if (id[0] === 0 && helpers.hasOwnProperty(id[1]) && ! scopedToContext) {\n      // first path segment is a helper\n      data = helpers[id[1]];\n    } else {\n      if ((! data instanceof Object) &&\n          (typeof (function() {})[id[1]] !== 'undefined') &&\n          ! scopedToContext) {\n        // Give a helpful error message if the user tried to name\n        // a helper 'name', 'length', or some other built-in property\n        // of function objects.  Unfortunately, this case is very\n        // hard to detect, as Template.foo.name = ... will fail silently,\n        // and {{name}} will be silently empty if the property doesn't\n        // exist (per Handlebars rules).\n        // However, if there is no data context at all, we jump in.\n        throw new Error(\"Can't call a helper '\"+id[1]+\"' because \"+\n                        \"it is a built-in function property in JavaScript\");\n      }\n      // first path segment is property of data context\n      data = (stack.data && stack.data[id[1]]);\n    }\n\n    // handle dots, as in {{foo.bar}}\n    for (var i = 2; i < id.length; i++) {\n      // Call functions when taking the dot, to support\n      // for example currentUser.name.\n      //\n      // In the case of {{foo.bar}}, we end up returning one of:\n      // - helpers.foo.bar\n      // - helpers.foo().bar\n      // - stack.data.foo.bar\n      // - stack.data.foo().bar.\n      //\n      // The caller does the final application with any\n      // arguments, as in {{foo.bar arg1 arg2}}, and passes\n      // the current data context in `this`.  Therefore,\n      // we use the current data context (`helperThis`)\n      // for all function calls.\n      if (typeof data === 'function') {\n        data = data.call(dataThis);\n        dataThis = data;\n      }\n      if (data === undefined || data === null) {\n        // Handlebars fails silently and returns \"\" if\n        // we start to access properties that don't exist.\n        data = '';\n        break;\n      }\n\n      data = data[id[i]];\n    }\n\n    // ensure `this` is bound appropriately when the caller\n    // invokes `data` with any arguments.  For example,\n    // in {{foo.bar baz}}, the caller must supply `baz`,\n    // but we alone have `foo` (in `dataThis`).\n    if (typeof data === 'function')\n      return _.bind(data, dataThis);\n\n    return data;\n  };\n\n  // 'extra' will be clobbered, but not 'params'.\n  // if (isNested), evaluate params.slice(1) as a nested\n  // helper invocation if there is at least one positional\n  // argument.  This is used for block helpers.\n  var invoke = function (stack, params, extra, isNested) {\n    extra = extra || {};\n    params = params.slice(0);\n\n    // remove hash (dictionary of keyword arguments) from\n    // the end of params, if present.\n    var last = params[params.length - 1];\n    var hash = {};\n    if (typeof(last) === \"object\" && !(last instanceof Array)) {\n      // evaluate hash values, which are found as invocations\n      // like [0, \"foo\"]\n      _.each(params.pop(), function(v,k) {\n        var result = eval_value(stack, v);\n        hash[k] = (typeof result === \"function\" ? result() : result);\n      });\n    }\n\n    var apply = function (values, extra) {\n      var args = values.slice(1);\n      for(var i=0; i<args.length; i++)\n        if (typeof args[i] === \"function\")\n          args[i] = args[i](); // `this` already bound by eval_value\n      if (extra)\n        args.push(extra);\n      return values[0].apply(stack.data, args);\n    };\n\n    var values = new Array(params.length);\n    for(var i=0; i<params.length; i++)\n      values[i] = eval_value(stack, params[i]);\n\n    if (typeof(values[0]) !== \"function\")\n      return values[0];\n\n    if (isNested && values.length > 1) {\n      // at least one positional argument; not no args\n      // or only hash args.\n      var oneArg = values[1];\n      if (typeof oneArg === \"function\")\n        // invoke the positional arguments\n        // (and hash arguments) as a nested helper invocation.\n        oneArg = apply(values.slice(1), {hash:hash});\n      values = [values[0], oneArg];\n      // keyword args don't go to the block helper, then.\n      extra.hash = {};\n    } else {\n      extra.hash = hash;\n    }\n\n    return apply(values, extra);\n  };\n\n  var template = function (stack, elts, basePCKey) {\n    var buf = [];\n\n    var toString = function (x) {\n      if (typeof x === \"string\") return x;\n      // May want to revisit the following one day\n      if (x === null) return \"null\";\n      if (x === undefined) return \"\";\n      return x.toString();\n    };\n\n    // wrap `fn` and `inverse` blocks in chunks having `data`, if the data\n    // is different from the enclosing data, so that the data is available\n    // at runtime for events.\n    var decorateBlockFn = function(fn, old_data) {\n      return function(data) {\n        // don't create spurious annotations when data is same\n        // as before (or when transitioning between e.g. `window` and\n        // `undefined`)\n        if ((data || Handlebars._defaultThis) ===\n            (old_data || Handlebars._defaultThis))\n          return fn(data);\n        else\n          return Spark.setDataContext(data, fn(data));\n      };\n    };\n\n    // Handle the return value of a {{helper}}.\n    // Takes a:\n    //   string - escapes it\n    //   SafeString - returns the underlying string unescaped\n    //   other value - coerces to a string and escapes it\n    var maybeEscape = function(x) {\n      if (x instanceof Handlebars.SafeString)\n        return x.toString();\n      return Handlebars._escape(toString(x));\n    };\n\n    var curIndex;\n    // Construct a unique key for the current position\n    // in the AST.  Since template(...) is invoked recursively,\n    // the \"PC\" (program counter) key is hierarchical, consisting\n    // of one or more numbers, for example '0' or '1.3.0.1'.\n    var getPCKey = function() {\n      return (basePCKey ? basePCKey+'.' : '') + curIndex;\n    };\n    var branch = function(name, func) {\n      // Construct a unique branch identifier based on what partial\n      // we're in, what partial or helper we're calling, and our index\n      // into the template AST (essentially the program counter).\n      // If \"foo\" calls \"bar\" at index 3, it looks like: bar@foo#3.\n      return Spark.labelBranch(name + \"@\" + getPCKey(), func);\n    };\n\n    _.each(elts, function (elt, index) {\n      curIndex = index;\n      if (typeof(elt) === \"string\")\n        buf.push(elt);\n      else if (elt[0] === '{')\n        // {{double stache}}\n        buf.push(branch(elt[1], function () {\n          return maybeEscape(invoke(stack, elt[1]));\n        }));\n      else if (elt[0] === '!')\n        // {{{triple stache}}}\n        buf.push(branch(elt[1], function () {\n          return toString(invoke(stack, elt[1] || ''));\n        }));\n      else if (elt[0] === '#') {\n        // {{#block helper}}\n        var pcKey = getPCKey();\n        var block = decorateBlockFn(\n          function (data) {\n            return template({parent: stack, data: data}, elt[2], pcKey);\n          }, stack.data);\n        block.fn = block;\n        block.inverse = decorateBlockFn(\n          function (data) {\n            return template({parent: stack, data: data}, elt[3] || [], pcKey);\n          }, stack.data);\n        var html = branch(elt[1], function () {\n          return toString(invoke(stack, elt[1], block, true));\n        });\n        buf.push(html);\n      } else if (elt[0] === '>') {\n        // {{> partial}}\n        var partialName = elt[1];\n        if (!(partialName in partials))\n          // XXX why do we call these templates in docs and partials in code?\n          throw new Error(\"No such template '\" + partialName + \"'\");\n        // call the partial\n        var html = branch(partialName, function () {\n          return toString(partials[partialName](stack.data));\n        });\n        buf.push(html);\n      } else\n        throw new Error(\"bad element in template\");\n    });\n\n    return buf.join('');\n  };\n\n  // Set the prefix for PC keys, which identify call sites in the AST\n  // for the purpose of chunk matching.\n  // `options.name` will be null in the body, but otherwise have a value,\n  // assuming `options` was assembled in templating/deftemplate.js.\n  var rootPCKey = (options.name||\"\")+\"#\";\n\n  return template({data: data, parent: null}, ast, rootPCKey);\n};\n\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}