)]}'
{"version":3,"file":"/packages/autoupdate.js","sources":["autoupdate/autoupdate_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kE;AACA,wD;AACA,E;AACA,sE;AACA,mE;AACA,uE;AACA,uD;AACA,E;AACA,+D;AACA,gE;AACA,2B;AACA,E;AACA,sE;AACA,qE;AACA,mC;AACA,E;AACA,kE;AACA,yE;AACA,c;AACA,E;AACA,oE;AACA,kE;AACA,sC;;AAEA,iE;AACA,W;AACA,iF;;;AAGA,gD;AACA,+E;;;AAGA,gB;;AAEA,6C;AACA,mC;AACA,Y;AACA,sB;AACA,qC;AACA,M;AACA,I;AACA,E;;;;AAIA,uB;AACA,0E;AACA,yE;AACA,qC;AACA,I;AACA,uE;AACA,uE;AACA,mE;AACA,+D;AACA,gD;AACA,wC;AACA,G;AACA,iB;;AAEA,6C;AACA,wD;AACA,+B;AACA,8D;AACA,iB;AACA,8C;AACA,qE;AACA,qE;AACA,wE;AACA,mE;AACA,+D;AACA,wE;AACA,+B;AACA,wC;AACA,S;AACA,M;AACA,0B;AACA,2B;AACA,6C;AACA,wD;AACA,qE;AACA,+B;AACA,4C;AACA,W;AACA,W;AACA,O;AACA,G;AACA,K;AACA,E;AACA,gC","sourcesContent":["// Subscribe to the `meteor_autoupdate_clientVersions` collection,\n// which contains the set of acceptable client versions.\n//\n// A \"hard code push\" occurs when the running client version is not in\n// the set of acceptable client versions (or the server updates the\n// collection, there is a published client version marked `current` and\n// the running client version is no longer in the set).\n//\n// When the `reload` package is loaded, a hard code push causes\n// the browser to reload, so that it will load the latest client\n// version from the server.\n//\n// A \"soft code push\" represents the situation when the running client\n// version is in the set of acceptable versions, but there is a newer\n// version available on the server.\n//\n// `Autoupdate.newClientAvailable` is a reactive data source which\n// becomes `true` if there is a new version of the client is available on\n// the server.\n//\n// This package doesn't implement a soft code reload process itself,\n// but `newClientAvailable` could be used for example to display a\n// \"click to reload\" link to the user.\n\n// The client version of the client code currently running in the\n// browser.\nvar autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\n\n\n// The collection of acceptable client versions.\nvar ClientVersions = new Meteor.Collection(\"meteor_autoupdate_clientVersions\");\n\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne(\n    {$and: [\n      {current: true},\n      {_id: {$ne: autoupdateVersion}}\n    ]}\n  );\n};\n\n\n\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n    onError: function (error) {\n      Meteor._debug(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function () {\n      if (Package.reload) {\n        Deps.autorun(function (computation) {\n          if (ClientVersions.findOne({current: true}) &&\n              (! ClientVersions.findOne({_id: autoupdateVersion}))) {\n            computation.stop();\n            Package.reload.Reload._reload();\n          }\n        });\n      }\n  }\n  });\n};\nAutoupdate._retrySubscription();\n"]}